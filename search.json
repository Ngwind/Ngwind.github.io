[{"title":"django初体验","url":"/2018/11/06/django学习记录/","content":"\n# 2018年10月29日\n\n## django 基本使用\n\n- 创建新工程：django-admin startproject 工程名\n- 创建新应用：django-admin startapp 应用名\n- 启动服务：python manage.py runserver 0.0.0.0:8000 \n\n## 文件目录\n\n- 工程配置文件：setting.py\n- 项目管理(操作)文件：manage.py\n\n# 2018年10月30日\n\n## django基础概念\n\n1. url配置：建立url和响应函数之间的关系。\n2. 视图views：想要客户http请求，进行逻辑处理，返回给用户http页面。响应函数都写在view文件中。\n3. 模型models：描述服务器存储的数据（数据库的表，另外django使用orm）\n4. 模板 templates：用来生产html页面，返回给用户的html，是由数据（模型）和模板渲染出来的\n\n# 2018年10月31日\n\n## 项目结构 \n```\n    .\n    ├── manage.py\n    └── myblog\n     ├── __init__.py\n     ├── settings.py\n     ├── urls.py\n     └── wsgi.py\n```\n### wsgi.py文件\n\n全称：python web server gatewagy interface(python服务器网关接口)\n作用：Python应用与web服务器之间的接口\n\n### urls.py文件\n\n作用：url配置文件。Django项目中所有地址(页面)都需要我们自己去配置其url\n\n### settings.py文件\n\n作用：项目的配置文件。里面包含了数据库，web应用，时间等各种配置\n\n## django的应用\n\ndjango的一个项目(project)是由多个应用(app)组成。每个app实现不同的功能\n\n### 创建应用\n\n命令语句:`python manage.py startapp 应用名`.例如：`python manage.py startapp blog`创建完应用后，还需要在settings.py文件中声明应用\n\n### 应用文件目录组成\n\n项目文件下会生成一个应用文件，文件名是应用的名字.例如之前的命令创建了一个blog的文件在myblog下面。blog文件的组成如下：\n```\n.\n├── admin.py\n├── apps.py\n├── __init__.py\n├── migrations\n│   └── __init__.py\n├── models.py\n├── tests.py\n└── views.py\n```\n文件作用：\n- migrations:数据迁移模块文件\n- admin.py：应用后台管理系统配置文件\n- apps.py:应用配置文件\n- models.py:数据模块，使用orm框架。类似mvc模式中的models\n- tests.py:自动化测试模块，可以编写测试脚本\n- views.py：执行响应代码所在的模块，代码逻辑处理的主要地带。项目中大部分代码均在此编写\n\n## 创建第一个页面(响应)\n\n### 编辑blog.views\n\n每一个响应页面对应一个函数，函数必须返回一个响应。函数必须存在一个参数，一般约定为request。每个响应对应一个url，后面还需要在urls.py文件中配置url。\n\n例如,创建一个显示hello world文本的响应页面：\n```python\nfrom django.http import HttpResponse\n# Create your views here.\n\ndef index(request):\n    return HttpResponse(\"Hello,world!\")\n    pass\n\n```\n\n### 编辑urls.py\n在urls.py中有一个urlpatterns列表。urlpatterns列表将URL对应到views。有关详细信息，请参阅：https：//docs.djangoproject.com/en/2.1/topics/http/urls/\n\n列举2种方法：\n1. Function views\n    - 先添加import：from my_app import views\n    - 然后添加一个url和views的匹配：path('', views.home, name='home')\n2. Including another URLconf\n    - 先添加include()方法: from django.urls import include, path\n    - 然后添加一个url和urls文件的匹配：path('blog/', include('blog.urls'))\n\nmyblog/urls.py文件:\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path, include\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('blog/', include('blog.urls')),\n]\n\n```\n\nblog/urls.py文件:\n\n```python\nfrom django.urls import re_path\nfrom . import views\n\nurlpatterns = [\n    re_path('^$', views.index),\n    re_path('', views.blog_other),\n]\n\n```\n\n\n\n\n# 2018年11月1日\n\n## django的templates\n\ndjango使用templates来存放模板页面（html文件）。\n\n### 创建templates\n\n- 第一步，在应用目录下，创建一个`template`文件夹\n- 第二步，在`templates`文件夹中再创建一个`blog`文件夹，在其中创建html文件（例如创建一个templates.html)。\n    ```html\n   <!DOCTYPE html>\n        <html lang=\"en\">\n            <head>\n                <meta charset=\"UTF-8\">\n                <title>{{ name }}</title>\n            </head>\n            <body>\n\n            </body>\n        </html>\n    ```\n   这样，模板文件就完成了。\n\n### 编辑views.py\n\n接下来，需要在views.py中编写一个响应函数来返回这个html页面。\n实例：\n```python\nfrom django.shortcuts import render //导入render方法\n\ndef blog_render(request):\n    return render(request, \"blog/templates.html\", {\"name\": \"wuwenda\"})  \n```\nrender主要接受三个参数：request对象、模板html页面地址、一个字典变量。在html中使用{{key}}来引用字典中的变量。render函数会返回一个HttpResponse对象。\n\n### 编辑urls.py\n\n最后，别忘了编辑urls.py文件中的页面和响应函数映射.在urls.py的urlpattern列表中加入：\n```python\n    re_path(\"^templates/$\", views.blog_templates),\n```\n运行服务，输入url:`127.0.0.1:8000/blog/templates/`就可以返回templates.html页面啦\n\n## django的models\n\ndjango提供了一个models来存放数据，使用的是orm(对象关系映射)思想。在models.py中编写数据结构。然后再views.py的响应函数中使用它。\n\n### 编辑models.py\n\nmodels.py中，创建一个继承自model。Models的class，表示一张表。在类中创建属性，表示一个字段。示例：\n\n创建一个文章的表，表的字段有varchar型的title、文本型的content. \n```python\nclass Article(models.Model):\n    title = models.CharField(max_length=32, default=\"我的标题\")\n    content = models.TextField(null=True)\n\n```\n### 执行migrate\n\n编写好数据结构后，并不能直接使用，先需要运行命令进行数据迁移（同步）\n\n在项目目录下运行下面两个命令：\n- `python manage.py makemigration` ----准备同步数据\n- `python manage.py migarte` ----同步数据\n\n### 使用models.py\n\n现在view.py中引入models模块，然后可以创建一个models中的类的对象。\n例如：获得artcile表中主键=1的那一行数据，然后存在一个article对象中返回，并且把这个数据加入到templates页面中返回。\n```python\nfrom . import models\n\ndef blog_models(request):\n    article = models.Article.objects.get(pk=1)\n    list_c = {\"name\": \"this is name\", \"article\": article}\n    return render(request, \"blog/models.html\", list_c)\n```\n新创建一个templates文件(models.html)\n```html\n<!DOCTYPE html>\n    <html lang=\"en\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <title>title</title>\n        </head>\n        <body>\n            <h1>{{ article.title }}</h1>\n            <p>{{ article.content }}</p>\n        </body>\n    </html>\n```\n\n最后，别忘了编辑urls.py文件中的页面和响应函数映射.在urls.py的urlpattern列表中加入：\n```python\n    re_path(\"^models/$\", views.blog_models),\n```\n运行服务，输入url:`127.0.0.1:8000/blog/models/`就可以返回models.html页面啦\n\n# 2018年11月6日\n\n## django的admin\n admin是django自带的管理后台，通过在 域名后加`/admin`进入管理后台\n\n### 管理员账号注册\n要使用admin需要先注册一个账号。在项目目录下，使用命令`python manage.py createsuperuser`.\n\n为了能够在后台管理数据库数据，还需要添加配置。在应用目录下的admin.py文件中添加配置：\n例如：\n```python\nfrom django.contrib import admin\nfrom .models import Article\n\nadmin.site.register(Article)\n\n```\n就是添加model.py中的类（数据库表）","tags":["django"]},{"title":"centos安装Python3","url":"/2018/10/29/centos安装Python3/","content":"\n## 前言\n\n在阿里云租用了云服务器。想安装python3学习django框架的时候，发现centos自带了python2.7.5.但是我们需要python3.5以上版本。从网上找到linux-centos7安装python3并与python2共存的教程，在此记录一下。\n\n> 引用自:https://www.cnblogs.com/JahanGu/p/7452527.html\n\n## 查看python版本\n\nCentOS 7.2 默认安装了python2.7.5，因为一些命令要使用它(比如`yum`命令)。\n\n使用`python -V`命令查看是否安装了python\n\n![](/img/201810291.jpg)\n\n然后使用`which python`命令查看python可执行文件的位置\n\n![](/img/1540823226.jpg)\n\n可见，执行文件在/usr/bin目录下。接着，我们用`cd /usr/bin`切换到该目录\n\n然后，使用`ls -l python*`命令查看\n\n![](/img/201810293.jpg)\n\n因为我们要安装python3版本，所以python要指向python3才行，目前还没有安装python3，先备份,备份之前先安装相关包，用于下载编译python3。不能忽略相关包\n`yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make`\n\n然后备份`mv python python.bak`\n\n## 编译安装python3\n\n去官网下载编译安装包:`wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz`\n\n解压缩:`xz -d Python-3.6.2.tar.xz`\n\n解tar包:`tar -xf ./Python-3.6.2.tar`\n\n`cd Python-3.6.2`进入路径\n\n执行下面的命令编译安装\n\n- `./configure prefix=/usr/local/python3`\n- `make && make install`\n\n安装成功后，/usr/local/目录下就会有python3了\n\n![](/img/201810294.jpg)\n\n## 添加软链\n\n接下来，我们添加软链到执行目录`/usr/bin`下。使用`ln -s /usr/local/python3/bin/python3 /usr/bin/python`命令。\n\n测试一下是否成功。执行：\n- `python -V`  看看输出的是不是python3的版本\n- `python2 -V`  看看输出的是不是python2的版本\n\n## 其他修改\n\n因为执行yum需要python2版本，所以我们还要修改yum的配置，执行：`vim /usr/bin/yum`,把\"#! /usr/bin/python\"修改为\"#! /usr/bin/python2\".\n\n同理 `vi /usr/libexec/urlgrabber-ext-down` 文件里面的\"#! /usr/bin/python\" 也要修改为\"#! /usr/bin/python2\".\n\n这样python3版本就安装完成；同时python2也存在\n\npython -V   版本3 \n\npython2 -V 版本2\n\n## pip和pip3\n\n即使我们安装了python3，但是pip命令还是指向python2环境。因此，要想使用pip安装库到python3环境，我们还需要修改一下pip。\n执行`ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3`命令，把pip3命令添加到执行路径。\n然后我们使用pip3就可以安装库到python3环境了。例如：使用`pip3 install django`来安装django库到python3环境中。\n\n这样使用pip命令可以安装库到python2环境，使用pip3命令可以安装库到python3环境！","tags":["linux"]},{"title":"selenium-元素定位","url":"/2018/09/20/selenium-元素定位/","content":"\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=298 height=52 src=\"//music.163.com/outchain/player?type=2&id=423226&auto=0&height=32\"></iframe>\n\n## 元素定位方法\n\n上一节我们已经配置好了环境并且可以通过脚本打开浏览器了，说明我们已经打开了自动化测试的大门，接下来就开始学习如何定位页面元素。\n\nhtml页面是由一个个的标签组成的，我们定位元素其实就是定位这些标签。selenium提供了8种查找定位元素的方法：\n\n- ID\n- name\n- Xpath\n- link test\n- partial link test\n- tag name\n- Class name\n- CSS selector  \n\n>最好的学习方法还是去源码！这写方法的使用方式，在源码注释中都有说明。\n>\n>在selenium包->webdriver文件夹->remote文件夹->webdriver.py\n\n为了方便演示，创建一个thml文件，文件内容如下：\n```Html\n<html>\n\n<body>\n  <p class=\"content\">Site content goes here.</p>\n  <form id=\"loginForm\">\n    <input name=\"username\" type=\"text\" />\n    <input name=\"password\" type=\"password\" />\n    <input name=\"continue\" type=\"submit\" value=\"Login\" />\n    <input name=\"continue\" type=\"button\" value=\"Clear\" />\n  </form>\n  <div>\n    <p>Are you sure you want to do this?</p>\n    <a href=\"continue.html\">Continue</a>\n    <a href=\"cancel.html\">Cancel</a>\n  </div>\n</body>\n<html>\n```\n\n提前介绍一下,这些函数都是通过webdriver对象来调用的，所以我们要先获得一个webdriver对象：\n\n```python\ndriver = webdriver.Chrome()\ndriver.get(\"file://C:/Users/Administrator/Desktop/learn-selenium.html\")  \n```\n\n## 通过ID查找元素\n\n对于属性有id的元素（标签），我们可用通过id查找元素。函数为`find_element_by_id(arg)`.这个方法会返回页面中第一个被匹配的元素对象。如果找不到任何元素，则抛出NoSuchElementException异常\n\n例如，可以通过下面的方式定位到from元素：\n\n```python\nelem_form = driver.find_element_by_id(\"loginForm\")\n```\n\n## 通过name查找元素\n\n对于属性有name的元素（标签），我们可用通过name查找元素。函数为`find_element_by_name(arg)`.这个方法会返回页面中第一个被匹配的元素对象。如果找不到任何元素，则抛出NoSuchElementException异常\n\n例如，可以通过下面的方式定位元素：\n```python\nelem_username = driver.find_element_by_name(\"username\")\nelem_password = driver.find_element_by_name(\"password\")\n```\n\n## 通过Xpath查找元素\n\nXPath是XML文档中查找结点的语法。因为HTML文档也可以被转换成XML(XHTML)文档， Selenium的用户可以利用这种强大的语言在web应用中查找元素。 XPath扩展了（当然也支持）这种通过id或name属性获取元素的简单方式，同时也开辟了各种新的可能性， 例如获取页面上的第三个复选框。\n\n使用XPath的主要原因之一就是当你想获取一个既没有id属性也没有name属性的元素时， 你可以通过XPath使用元素的绝对位置来获取他（这是不推荐的），或相对于有一个id或name属性的元素 （理论上的父元素）的来获取你想要的元素。XPath定位器也可以通过非id和name属性查找元素。\n\n绝对的XPath是所有元素都从根元素的位置（HTML）开始定位，只要应用中有轻微的调整，会就导致你的定位失败。 但是通过就近的包含id或者name属性的元素出发定位你的元素，这样相对关系就很靠谱， 因为这种位置关系很少改变，所以可以使你的测试更加强大。\n\n函数为`find_element_by_xpath(arg)`.arg为xpath表达式。\n\n例如，通过下面方式定位元素：\n```python\nclear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\")\nelem_p = driver.find_element_by_xpath(\"//p\")\n```\n通过xpath查找定位的方式很强大，不过要用好xpath定位，还需要进一步掌握xpath的语法。\n\n>学习xpath定位:https://www.jianshu.com/p/89c10770d72c\n\n## 通过link text查找元素\n\n当你知道在一个锚标签中使用的链接文本时，可以使用链接文本定位。页面中第一个匹配链接内容锚标签会被匹配并返回。如果找不到任何元素，会抛出`NoSuchElementException`异常。\n\n使用`find_element_by_link_text(arg)`,返回链接文本匹配arg的标签。此外，也可以使用`find_element_by_partial_link_text(arg)`,返回链接文本包含arg的标签。\n\n例如，通过下面方式定位元素：\n```python\ncontinue_link = driver.find_element_by_link_text('Continue')\ncontinue_link = driver.find_element_by_partial_link_text('Conti')\n```\n\n## 通过tag name查找元素\n\n如果你想通过标签名来定位元素，可以使用函数`find_element_by_tag_name(arg)`.不过这个方法定位不是很好用，毕竟页面中的同tag有很多个嘛.同样，如果找不到任何元素，会抛出`NoSuchElementException`异常。\n\n例如，通过下面方式定位元素：\n\n```python\nelem_form_tag = driver.find_element_by_tag_name(\"form\")     \n```\n\n## 通过class name查找元素\n\n对于属性有class的元素（标签），我们可用通过class查找元素。函数为`find_element_by_class_name(arg)`.这个方法会返回页面中第一个被匹配的元素对象。如果找不到任何元素，则抛出NoSuchElementException异常。\n\n例如，通过下面方式定位元素：\n\n```python\nelem_content = driver.find_element_by_class_name(\"content\")    \n```\n\n但是，在实际情况下有些元素会有多个class，这时候不能定位成功，一般较少用classname进行定位查找。\n\n## 通过css选择器查找元素\n\n通过css selector来查找也是一种强大的方法，它和xpath不相上下。函数为`find_element_by_css_selector(arg)`.这个方法会返回页面中第一个被匹配的元素对象。如果找不到任何元素，则抛出NoSuchElementException异常。\n\n例如，通过下面方式定位元素：\n```python\nelem_continue_css = driver.find_element_by_css_selector(\"p.content\")\n```\n\n## 用elements查找多个\n\nwebdriver中还有一类函数，它和find_element_by类似，不过这类函数不是返回单个匹配的元素，而是返回所有匹配的元素组成的列表。只要把element改成elements就可以了。例如：`find_elements_by_xpath()`、`find_elements_by_id()`等等。\n\n## 通用的查找方法\n\n可以使用webdriver的`find_element(by,arg)`函数。By类中可以选择定位的方法（上面提到的8种），arg为匹配的字符串。不过，官方文档中建议我们优先使用上面的具体定位方法。\n\n此外，也有`find_elements(by,arg)`函数，返回所有匹配元素组成的列表。\n\n## 总结\n\n定位元素是web自动化的重要基础，需要熟练掌握，多多练习。定位元素的方法有很多，特别要掌握xpath或css selector这两种强大的定位方式。认真学习xpath的语法吧!\n\n","tags":["selenium"]},{"title":"selenium-环境准备","url":"/2018/09/20/selenium-环境准备/","content":"\n## 介绍\n\nselenium提供了一个简单的API，让我们使用Selenium WebDriver来编写功能/校验测试。selenium支持java、ruby、python等多种语言。我们使用python。\n\n通过Selenium Python的API，可以非常直观的使用Selenium WebDriver的所有功能。\n\n## 安装前提\n\n首先，要保证安装了Python，pycharm和chrome浏览器（或者firefox等）\n此外安装python后应该有顺带安装了pip\n\n## 安装selenium包\n\n打开cmd命令行，通过pip来安装selenium包。\n\n在命令行中输入`pip install selenium`，等待安装完成。\n\n安装完成后，可以通过`pip show selenium`，来查看selenium是否安装成功。正常情况下会显示selenium包的相关信息。\n\n![](/img/2018-09-20 103115.png)\n\n## 安装webdriver\n\n使用selenium进行web自动化测试的原理是：selenium给我们提供了api，我们调用这些api，selenium会与webdriver（浏览器驱动程序）打交道，完成我们想要对浏览器进行的操作。\n\n因此。我们除了安装selenium包，还要安装浏览器驱动webdriver。不同浏览器的驱动是不一样的。我一般使用chrome浏览器，所以下载安装chromedriver。\n\n这是chromedriver的镜像下载地址：http://npm.taobao.org/mirrors/chromedriver/\n\n![](/img/2018-09-20 104323.png)\n\n应该选择支持你浏览器的chromedriver。\n\n在chrome浏览器中，点击左上角省略号图标->帮助->关于，就可以看到chrome浏览器版本。\n\n在页面的LATEST_RELEASE文件中可以看到最新的webdriver版本。点击进入其中一个版本文件夹，然后打开里面的note.txt文件，里面有说明各个版本的webdriver所支持的浏览器版本。\n\n下载完成chromedriver后解压，还要把它放在正确的位置。放在python文件夹->Scripts文件夹 中。参考我的路径：`D:\\software\\python\\Scripts`。\n\n## 验证一下\n\n如果完成上述步骤，按道理就应该可以使用selenium了。\n\n新建一个工程，创建python文件，编写代码：\n```python\nfrom selenium import webdriver  # 导入包\ndriver = webdriver.Chrome()  # 打开一个浏览器\ndriver.get(\"http://www.baidu.com\")  # 搜索栏中输入网址并访问 \n```\n\n如果pycharm没有识别出selenium包，可能是由于你使用的解释器不对。把python解释器设置成python目录下的python.exe。例如我的路径是：`D:\\software\\python`，python.exe在该文件夹下。\n\n如何修改python解释器自行百度。\n\n","tags":["selenium"]},{"title":"Python之闭包、装饰器","url":"/2018/09/18/Python之闭包、装饰器/","content":"\n## 什么是闭包\n\n在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。\n\n上面提到了两个关键的地方： 自由变量 和 函数, 这两个关键稍后再说。还是得在赘述下“闭包”的意思，望文知意，可以形象的把它理解为一个封闭的包裹，这个包裹就是一个函数，当然还有函数内部对应的逻辑，包裹里面的东西就是自由变量，自由变量可以在随着包裹到处游荡。当然还得有个前提，这个包裹是被创建出来的。\n\n再通过Python的语言介绍一下，一个闭包就是你调用了一个函数A，这个函数A返回了一个函数B给你。这个返回的函数B就叫做闭包。你在调用函数A的时候传递的参数就是自由变量。\n举个栗子：\n\n```python\ndef fa(n):\n    num = 1\n    def fb():\n        return n+num\n    return fb\n# 测试代码：\nf = fa(1)\nprint(\"f不是直接等于2，而是一个函数,f:\", f)\nprint(\"f()返回结果才等于2,f():\", f())\n```\n\n调用fa的时候就产生了一个闭包fb，并且该闭包持有自由变量num，因此这意味着，当函数func的生命周期结束之后，name这个变量依旧存在，因为他被闭包引用了，所以不会回收。\n\n## 举例闭包的使用场景\n\n```python\ndef func_150(val):   # 总分为150时，及格分数为90\n    passline = 90\n    if val >= passline:\n        print \"pass\"\n    else:\n        print \"fail\"\n\ndef func_100(val):   # 总分为100时，及格分数为60\n    passline = 60 \n    if val >= passline:\n        print \"pass\"\n    else:\n        print \"fail\"\n\nfunc_100(89)  \nfunc_150(89)\n使用闭包优化上面的代码：\n\ndef set_passline(passline):\n    def cmp(val):\n        if val >= passline:\n            print \"pass\"\n        else:\n            print \"fail\"\n    return cmp\n\nf_100 = set_passline(60)    # f_100调用函数set_passline()，并将60赋值给变量passline,这是f_100等于函数的返回值，也就是函数cmp\nf_150 = set_passline(90)\nf_100(89)     # f_100()=cmp(),将89赋值给val，运行cmp()函数，输出结果\nf_150(89)\n\n```\n\n## nonlocal语句\n\n在python的函数内，可以直接*引用*外部变量，但是不能*改写*外部变量，因此如果在闭包中直接改写父函数的变量，就会发生错误，例如：\n\n```python\ndef fa(n):\n    num = 1\n\n    def fb():\n        num = num+1 # 这里会出错！ 改写了外部变量！\n        return n+num\n    return fb\n\n# 测试代码：\nf = fa(1)\n```\n在python2中可以在函数内使用global语句，但是全局变量在任何语言中都不被提倡，因为它很难控制，python3中引入了nonlocal语句来解决这个问题：\n\n```python\ndef fa(n):\n    num = 1\n\n    def fb():\n        nonlocal num  #　声明了nonlocal不会报错了\n        num = num+1 \n        return n+num\n    return fb\n\n# 测试代码：\nf = fa(1)\n```\n\nnonlocal与global的区别在与nonlocal语句回去搜寻本地变量与全局变量之间的变量，其会优先寻找层级关系与闭包作用域最近的外部变量。\n\n## 装饰器模式\n\n装饰器是函数闭包的一种应用。装饰器函数用来装饰一般函数（给一个函数增加额外的功能），然后返回新的函数对象给函数本身。具体还是看代码演示：\n\n```python\ndef decorator(func): # 定义装饰器函数,输出函数的开始时间和结束时间\n    def after_decor():\n        print(func.__name__, \"start:\")\n        func()\n        print( func.__name__, \"end...\")\n    return after_decor\n\n@decorator\ndef bark():  # 定义bark函数，然后使用decorator函数来装饰他\n    for i in range(3):\n        print(\"Wooo~\")\n        time.sleep(1)\n\n# 测试代码\nbark()  #　调用bark函数\n```\n\n运行结果：\n\n```\nbark start:\nWooo~\nWooo~\nWooo~\nbark end...\n```\n\n## 闭包的作用\n\n闭包的最大特点是可以将父函数的变量与内部函数绑定，并返回绑定变量后的函数（也即闭包），此时即便生成闭包的环境（父函数）已经释放，闭包仍然存在，这个过程很像类（父函数）生成实例（闭包），不同的是父函数只在调用时执行，执行完毕后其环境就会释放，而类则在文件执行时创建，一般程序执行完毕后作用域才释放，因此对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，且更轻巧灵活\n\n闭包可以避免全局变量的使用。\n\n对闭包的理解还是需要多多实践，多多体会。\n\n> 本文参考:\n> http://www.mylanbitou.top/blog/detail/3/#Coon\n","tags":["python"]},{"title":"Python之hashlib模块","url":"/2018/09/17/Python之hashlib模块/","content":"\n### hashlib介绍\n\nPython的hashlib提供了常见的摘要算法，如MD5，SHA1等等。\n\n什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。\n\n举个例子，你写了一篇文章，内容是一个字符串 `how to use python hashlib - by Michael'，并附上这篇文章的摘要是'2d73d4f15c0db7f5ecb321b6a65e5d6d'。如果有人篡改了你的文章，并发表为'how to use python hashlib - by Bob'，你可以一下子指出Bob篡改了你的文章，因为根据'how to use python hashlib - by Bob'计算出的摘要不同于原始文章的摘要。\n\n可见，摘要算法就是通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过。\n\n摘要算法之所以能指出数据是否被篡改过，就是因为摘要函数是一个单向函数，计算f(data)很容易，但通过digest反推data却非常困难。而且，对原始数据做一个bit的修改，都会导致计算出的摘要完全不同。\n\n### 使用hashlib\n\n通过hashlib.hash函数名（）来获得一个hash对象。比如获得一个md5hash函数对象：\n\n```python\nm = hashlib.md5()\n```\n\n#### hash对象的方法\n\nhash对象有四个常用的方法：\n - update（arg)\n - digest()\n - hexdigest()\n - copy()\n\n##### update方法\n\nupdate(arg)方法使用arg中的字节来更新hash对象。arg参数要指明编码格式,否则报错。\n\n注意：如果多次调用同一个hash对象的update方法。相当于多个arg拼接在一起。（后面会有演示）\n\n```python\nm.update(\"wuwenda\".encode(\"utf-8\"))\n```\n\n##### digest方法\n\ndigest()返回加密后的密文（准确说是摘要信息）\n```python\ndig = m.digest()\nprint(dig)\n```\n运行结果：\n```\nb'*?\\xc1\\xe1w\\xa1\\xe9g\\x1d\\x1d\\x10\\x83t}u\\xad'\n```\n\n##### hexdigest方法\n\nhexdigest()方法和digest方法类似的,只不过返回的密文是作为双倍长度的unicode对象返回的，只包含十六进制字符。\n\n```python\ndig = m.digest()\nprint(dig)\nprint(type(dig))\nhdig = m.hexdigest()\nprint(hdig)\nprint(type(hdig))\n```\n运行结果：\n```\nb'*?\\xc1\\xe1w\\xa1\\xe9g\\x1d\\x1d\\x10\\x83t}u\\xad'\n<class 'bytes'>\n2a3fc1e177a1e9671d1d1083747d75ad\n<class 'str'>\n```\n可以看出，digest方法返回的是bytes对象，hexdigest方法返回的是str对象。\n\n##### copy方法\n\ncopy()方法返回hash对象的副本.这个功能主要用来提升代码性能，如果有子字符串多次被使用，则可以使用copy方法直接，避免重复的hash计算。\n\n#### 同一hash对象多次使用update(arg)\n\n注意看下面两种方法，它们生成的摘要都是相同的。希望可以通过这个例子，来明白多次调用的情况。\n\n1. 使用一次update\n  \n   ```python\n   m1 = hashlib.md5()\n   m1.update(\"wuwenda123\".encode(\"utf-8\"))   \n   print(m1.hexdigest())\n   ```\n\n   输出为：\n\n   ```\n   a06c86d9a4df8de61c90af9bfd7572c9\n   ```\n\n2. 使用两次update\n   ```python\n   m2 =hashlib.md5()\n   m2.update(\"wuwenda\".encode(\"utf-8\"))\n   m2.update(\"123\".encode(\"utf-8\"))\n   print(m2.hexdigest())\n   ```\n\n   输出为：\n\n   ```\n   a06c86d9a4df8de61c90af9bfd7572c9\n   ```\n\n多次调用update()就相当于把多个arg参数拼接\n","tags":["python"]},{"title":"路由技术-ospf路由","url":"/2018/09/07/拼客学院-路由技术-ospf路由/","content":"\n###  1 ospf实现校园网跨区域通信\n\n![](/img/1536292550.jpg)\n\n#### 1.1 为路由器配置直连地址，保证直连联通\n\n#### 1.2 为路由器配置环回接口，模拟不同校区\n\n#### 1.3 为路由器配置ospf协议，实现全网联通\n\nR1#\n```\nconf t\nrouter ospf 100\nrouter-id 1.1.1.1\nnetwork 1.1.1.1 0.0.0.0 area 1\nnetwork 12.1.1.0 0.0.0.255 area 0\nnetwork 13.1.1.0 0.0.0.255 area 0\n```\nR2#\n```\nconf t\nrouter ospf 100\nrouter-id 2.2.2.2\nnetwork 2.2.2.2 0.0.0.0 area 2\nnetwork 12.1.1.0 0.0.0.255 area 0\nnetwork 13.1.1.0 0.0.0.255 area 0\n```\nR3#\n```\nconf t\nrouter ospf 100\nrouter-id 3.3.3.3\nnetwork 3.3.3.3 0.0.0.0 area 1\nnetwork 12.1.1.0 0.0.0.255 area 0\nnetwork 13.1.1.0 0.0.0.255 area 0\n```\n\n### 2 常见调试命令\n\n测试连通性`ping xxxx`\n\n带源测试`ping xxxx source yyyy`\n\n查看接口状态`show ip int brief`\n\n查看ospf配置`show run | s r o`\n\n查看路由表`show ip route`\n\n查看ospf路由`show ip route ospf`","tags":["拼客学院"]},{"title":"路由技术之静态路由","url":"/2018/09/07/拼客学院-路由技术-静态路由/","content":"\n### 0 GNS3入门与安装\n\n### 1 IOS基础操作\n\n![](/img/201809070927.png)\n\n1. 为R1和R2配置接口ip地址，打开接口\n2. 安装wireshark并集成到GNS3里面\n3. 抓取R1和R2之间的通讯数据，并通过wireshark进行分析\n4. 将R2设置为telnet服务器，并从R1远程登陆R2\n\n### 2 静态路由实验\n\n![](/img/1536283934.png)\n\n1. 配置R1和R2的直连ip地址，保证直连ping通\n\nR1#\n```\nconf t\nint f0/0\nip address 12.1.1.1 255.255.255.0\nno shutdown\n```\n\nR2#\n```\nconf t\nint f0/0\nip address 12.1.1.2 255.255.255.0\nno shutdown\n```\n\nR1#\n```\nping 12.1.1.2\n```\n\nR1#\n```\nping 12.1.1.1\n```\n\n2. 通过loopback口，模拟局域网主机\n\nR1#\n\n```\nint lo 1\nip add 1.1.1.1 255.255.255.0 \nshow ip interface biref \n```\n\nR2#\n\n```\nint lo 1\nip add 2.2.2.2 255.255.255.0 \nshow ip interface biref \n```\n3. 为R1和R2设置静态路由\n\nR1#\n```\nip route 2.2.2.0 255.255.255.0 f0/0\n```\nR2#\n```\nip route 1.1.1.0 255.255.255.0 f0/0\n```\n\n4. 查看路由表\n\n```\nshow ip route\n```\n\n5. 最终要求主机之间能够相互ping通。(带源ping)\n\nR1#\n```\nping 2.2.2.2 soure 1.1.1.1\n```\nR2#\n```\nping 1.1.1.1 soure 2.2.2.2\n```\n\n### 3 配置默认路由+浮动路由\n\n![](/img/201809070933.jpg)\n\n\n1. 配置直连ip地址，保证直连ping通\n2. 在R2上创建换回接口，模拟互联网服务器\n3. 在R1上部署默认路由，实现R1访问互联网所有服务器\n\n```\nip route 0.0.0.0 0.0.0.0 12.1.1.12\n```\n\n4. 在R1上部署浮动路由，实现主备链路切换\n\n```\nip route 0.0.0.0 0.0.0.0 13.1.1.13 100\n```\n\n5. 在R1上查看路由表\n\n```\nshow ip route\n```\n\n6. 验证主备切换效果\n\n调试ping包\n\n```\ndebug ip icmp\n```\n","tags":["拼客学院"]},{"title":"Python之Time模块","url":"/2018/08/14/Python之Time模块/","content":"## 0 前言\n\n最近抽空学习了Python的Time模块。time模块主要用来获取和处理时间相关的数据。这个模块还是比较简单易懂的。接下来介绍一下time模块的主要函数。\n\n## 1 Time介绍\n\n首先，time模块中用到的时间数据类型有3类：时间戳、时间元组、时间字符串。\n- 时间戳是float型数据，表示从1970年1月1日到某个时间点的总计秒数。\n- 时间元组是time模块中定义的tuple类型数据。主要有9部分：\n  - m_year 年\n  - tm_mon 月\n  - tm_mday 日\n  - tm_hour 小时\n  - tm_min 分钟\n  - tm_sec 秒钟\n  - tm_wday 星期\n  - tm_yday 月份\n  - tm_isdst 是否夏令时\n  \n  官方文档中这样介绍：\n  ```python\n    The other representation is a tuple of 9 integers giving local time.\n    The tuple items are:\n  year (including century, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\n    If the DST flag is 0, the time is given in the regular time zone;\n    if it is 1, the time is given in the DST time zone;\n    if it is -1, mktime() should guess based on the date and time.\n  ```\n- 时间字符串是string类型的数据，一种便于阅读的时间数据表示形式。\n  \n## 2 主要函数\n\n#### time()\n\ntime函数返回当前时间戳\n\n示例：\n```python\nt1 = time.time()  # time函数返回当前时间戳-float型数据\nprint(\"time函数返回当前时间戳-float型数据\")\nprint(t1)\nprint(type(t1), \"\\n\")\n```\n输出：\n```python\ntime函数返回当前时间戳-float型数据\n1534260500.7620687\n<class 'float'> \n```\n\n#### localtime(secs)\n\nlocaltime函数可以接收一个时间戳，返回一个时间元组；如果参数为空，则返回当前时间的元组。\n\n示例：\n```python\nt2 = time.localtime(1493890956)  # localtime函数接受一个时间戳，返回一个时间元组\nprint(\"localtime函数接受一个时间戳，返回一个时间元组\")\nprint(t2)\nprint(type(t2), \"\\n\")\n```\n输出\n```python\nlocaltime函数接受一个时间戳，返回一个时间元组\ntime.struct_time(tm_year=2017, tm_mon=5, tm_mday=4, tm_hour=17, tm_min=42, tm_sec=36, tm_wday=3, tm_yday=124, tm_isdst=0)\n<class 'time.struct_time'> \n```\n\n#### asctime(t)\n\nasctime函数接受一个时间元组，返回一个格式化的字符串\n\n示例：\n```python\nt3 = time.asctime(t2)  # asctime函数接受一个时间元组，返回一个格式化的字符串\nprint(\"asctime函数接受一个时间元组，返回一个格式化的字符串\")\nprint(t3)\nprint(type(t3), \"\\n\")\n```\n输出：\n```python\nasctime函数接受一个时间元组，返回一个格式化的字符串\nThu May  4 17:42:36 2017\n<class 'str'> \n```\n\n#### ctime(secs)\n\nctime函数相当于localtime+asctime的结合\n\n示例：\n```python\nt4 = time.ctime(t1)  # ctime函数相当于localtime+asctime的结合\nprint(\"ctime函数相当于localtime+asctime的结合\")\nprint(t4)\nprint(type(t4), \"\\n\")\n```\n输出：\n```python\nctime函数相当于localtime+asctime的结合\nTue Aug 14 23:28:20 2018\n<class 'str'> \n```\n#### strftime(format,t)\n\nstrftime函数将时间元组转换成格式化时间字符串\n\n示例：\n```python\nt5_1 = time.strftime('%Y-%m-%d %H:%M:%S %a %b', t2)  # strftime函数将时间元组转换成格式化时间字符串\nt5_2 = time.strftime('%A %B %p %I:%M:%S %z')\nprint(\"strftime函数将时间元组转换成格式化时间字符串\")\nprint(t5_1)\nprint(t5_2, '\\n')\n\n```\n输出：\n```python\nstrftime函数将时间元组转换成格式化时间字符串\n2017-05-04 17:42:36 Thu May\nTuesday August PM 11:28:20 +0800 \n```\n#### strptime(str,format)\n\nstrptime函数将字符串解析，输出时间元组\n\n示例：\n```python\nt6 = time.strptime('2018年8月14日10点3分45秒', '%Y年%m月%d日%H点%M分%S秒')  # strptime函数将字符串解析，输出时间元组\nprint(\"strptime函数将字符串解析，输出时间元组\")\nprint(t6)\nprint(type(t6), \"\\n\")\n```\n输出：\n```python\nstrptime函数将字符串解析，输出时间元组\ntime.struct_time(tm_year=2018, tm_mon=8, tm_mday=14, tm_hour=10, tm_min=3, tm_sec=45, tm_wday=1, tm_yday=226, tm_isdst=-1)\n<class 'time.struct_time'> \n```\n#### gmtime(secs)\n\ngmtime函数接收时间戳输出格林尼治时间元组\n\n示例：\n```python\nt7 = time.gmtime(t1)  # gmtime函数接收时间戳输出格林尼治时间元组\nprint(\"mgtime函数接收时间戳输出格林尼治时间元组，注意loacltime()是输出本地区的时间元组\")\nprint(t7)\nprint(type(t7), \"\\n\")\n```\n输出：\n```python\ngmtime函数接收时间戳输出格林尼治时间元组，注意loacltime()是输出本地区的时间元组\ntime.struct_time(tm_year=2018, tm_mon=8, tm_mday=14, tm_hour=15, tm_min=28, tm_sec=20, tm_wday=1, tm_yday=226, tm_isdst=0)\n<class 'time.struct_time'> \n```\n#### mktime(t)\n\nmktime函数与gmtime函数相反，接收一个时间元组输出时间戳\n\n示例：\n```python\nt8 = time.mktime(t7)  # mktime函数与gmtime函数相反，接收一个时间元组输出时间戳\nprint(\"mktime函数与gmtime函数相反，接收一个时间元组输出时间戳\")\nprint(t8)\nprint(type(t8), \"\\n\")\n```\n输出：\n```python\nmktime函数与gmtime函数相反，接收一个时间元组输出时间戳\n1534231700.0\n<class 'float'> \n\n```\n#### clock()\n\n返回进程开始后的cpu运行时间\n\n示例：\n```python\nt3 = time.asctime(t2)  # asctime函数接受一个时间元组，返回一个格式化的字符串\nprint(\"asctime函数接受一个时间元组，返回一个格式化的字符串\")\nprint(t3)\nprint(type(t3), \"\\n\")\n```\n输出：\n```python\n返回进程开始后的cpu运行时间\nE:/PycharmProjects/practise_20180814/test_time.py:63: DeprecationWarning: time.clock has been deprecated in Python 3.3 and will be removed from Python 3.8: use time.perf_counter or time.process_time instead\n5.021518962\n  t10 = time.clock()  # 返回进程开始后的cpu运行时间\n<class 'float'> \n```\n\n这里警告说clock函数将在3.8版本被抛弃，新版本建议使用pref_counter()和process_time().\n\n#### sleep(secs)\n\n推迟调用线程的运行，secs指秒数。\n\n示例：\n```python\nt9 = time.sleep(5)  # 推迟调用线程的运行，secs指秒数。\nprint(\"推迟调用线程的运行，secs指秒数。\")\nprint(t9)\nprint(type(t9), \"\\n\")\n```\n输出：\n```python\n推迟调用线程的运行，secs指秒数。\nNone\n<class 'NoneType'> \n```\n\n## 3 最后\n附上一个关系图：\n\n![](/img/2018-08-20 093311.png)\n\ntime模块比较简单也是比较常用的模块，要搞清楚3种数据类型的转化。此外，还可以使用sleep（）来挂起线程。接下来会学习与time模块相关的模块calendar模块\n\n---\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=503602561&auto=1&height=66\"></iframe>\n","tags":["python"]},{"title":"三、【fiddler】之修改响应内容","url":"/2018/08/13/fiddler之修改响应内容/","content":"\n### 前言\n\n本节介绍使用fiddler的autoresponder来截获并且修改服务器的响应。\n>参考文章：https://docs.telerik.com/fiddler/KnowledgeBase/AutoResponder\n\n### AutoResponder的介绍\n\nFiddler的AutoResponder选项卡允许您从本地磁盘返回文件，而不是将请求发送到服务器。\n\n打开autoresponder选项，ui如图所示：\n\n![](/img/2018-08-13 155331.png)\n\n- 3个勾选框\n  - Enable rule 勾选此项表示规则生效\n  - Unmatched request passthroght 勾选此项表示没有匹配上规则的请求可以通过\n  - EnableLatency 勾选此项表示响应延迟设置生效\n- 2个按钮\n  - Add Rule 点击按钮新增一个规则\n  - Import... 点击按钮导入本地已有规则\n- 规则列表 \n  - If request matches 显示匹配规则\n  - then respond with 显示修改后的响应\n  - Latency 显示延迟\n  - Comments 显示备注\n- 规则编辑器\n  - rules 关键部分，匹配的规则。默认给出了很多种匹配规则\n  - match 关键部分，匹配后对进行的操作\n  - match only once\n  - test 测试匹配效果\n  - save 保存编辑内容\n  \n####  创建AutoResponder规则\n废话少说，我们示范一个使用autoresponder修改百度页面图片的例子。\n\n首先打开fiddler抓包，然后在浏览器中打开`www.baidu.com`,之后在fiddler里就可以看到一些数据包了。\n\n![](/img/2018-08-13 170143.png)\n\n查看这个请求的响应，是一个icon图片。把图片保存到本地，然后再进行一些修改。\n\n![](/img/2018-08-13 170459.ico)\n\n接着，我们切换到autoresponder界面，把请求:`https://www.baidu.com/favicon.ico`拖拽到autoresponder界面（自己手动输入也行）。\n\n![](/img/2018-08-13 170813.jpg)\n\n然后是关键的一步，修改请求内容。选择刚刚创建的rule，把响应改为使用本地文件：\n\n![](/img/2018-08-13 171006.png)\n\n把之前修改的本地文件作为服务器响应文件：\n\n![](/img/2018-08-13 171046.png)\n\n不要忘记点击save、勾选enable rule，并且清除一些浏览器缓存。接下来我们再访问一次`www.baidu.com`,观察页面显示情况。\n\n![](/img/2018-08-13 171522.jpg)\n\n可以发现，百度页面的icon图成功替换成了我们本地的图片！\n\n#### Matching Rules\n\n##### 字符串匹配\n\nFiddler将匹配字符串文字（不区分大小写）\n\n##### 不包含字符串匹配\n\n仅当字符串不匹配时才应用该规则\n\n##### 完全匹配\n\nFiddler支持精确的，区分大小写的匹配语法，用于以exact开头的表达式\n\n##### 正则表达式\n\nFiddler支持以正则表达式开头的表达式的正则表达式语法。\n正则表达式将用于使用“操作”列中的字符串替换入站URL。\n使用。+匹配一个或多个字符的序列，或。*匹配零个或多个字符。\n在正则表达式的前面使用^表示“URL的开头”，并在正则表达式的尾部使用$表示“URL的结尾”。\n\n#### Action\n\n除了简单地返回文件，AutoResponder还可以执行特殊操作.\n\n##### filename\n\n返回文件名的内容作为响应。\n\n\n##### http://targetURL\n\n返回targetURL的内容作为响应\n\n##### *redir:http://targetURL\n\n将HTTP重定向返回到目标URL。与简单的URL规则不同，这可以确保客户端知道其请求的位置，以便发送正确的cookie等。\n\n##### *bpu\n\n在发送到服务器之前中断请求。非最终行动。\n\n##### *bpafter\n\n向服务器发送请求并中断响应。非最终行动。\n\n##### *delay:####\n\n通过####毫秒来延迟向服务器发送请求。非最终行动。\n\n##### *header:Name=Value\n\n将具有给定Name的Request标头设置为指定值。如果不存在该名称的标头，则将创建新标头。非最终行动。\n\n##### *flag:Name=Value\n\n将具有给定Name的会话标志设置为指定值。如果不存在该名称的标头，则将创建新标头。非最终行动。\n\n##### *CORSPreflightAllow\n\n返回表示允许CORS的响应\n\n##### *reset\n\n使用TCP / IP RST立即重置客户端连接到客户端\n\n##### *drop\n\n不发生响应，马上关闭客户端连接\n\n##### *exit\n\n终止进程\n\n#### Latency \n\n你可以设置服务器响应的延迟时间，记得勾选Enable Latency。选择一个规则，然后右键点击-》set latency，就可以设置延时了。\n\n![](/img/2018-08-13 181344.png)\n\n### 最后\n\nAutoResponder 是 Fiddler 比较重要且比较强大的功能之一。可用于拦截某一请求，并重定向到本地的资源，或者使用Fiddler的内置响应。可用于调试服务器端代码而无需修改服务器端的代码和配置，因为拦截和重定向后，实际上访问的是本地的文件或者得到的是Fiddler的内置响应。","tags":["fiddler"]},{"title":"三、【fiddler】之发送请求","url":"/2018/08/08/fiddler之composer的使用/","content":"\n### 0 前言\n\nfiddler是一个强大的抓包工具。不过除了使用它进行抓包分析，我们还能使用它来发送请求request。接下来介绍如何使用fiddler发送请求。\n\n---\n\n### 1 Composer\n\nfiddler的左边tab栏中有一个\"Composer\"栏。正如它的名字意思：\"作曲家\",我们在Composer中发送请求。点开Composer栏，它的界面组成如下图：\n\n![](/img/2018-08-08 010342.jpg)\n\n它有一个Execute按钮,当我们写好http请求后，点击按钮就可以发送请求了。不过先不急，我们先介绍它的4个tab栏：Parsed、Raw、Scratchpad、Options\n\n#### 1.1 Parsed\n\n点击进入Parsed，在这里我们能方便快速地编写请求。\n\n![](/img/2018-08-08 012002.jpg)\n\n- 在左上角可以选择请求方法。常用方法有：GET、POST、PUT、HEAD...\n- 在中间输入你要请求的url。\n- 然后在后面的框中选择http协议版本。\n- 下面第一个文本框是填写头文件Header的。\n- 底下的文本框用来填写body。选择POST方法，则可以编辑body文本框。还可以点击蓝色字‘upload file’来上传文件。\n- 最右边可以看到之前发送过的请求。勾选了log requests就可以保存request请求记录\n\n此外，我们可以直接把左边session list中的一个session拖到Composer中，点击execuet运行请求。\n\n##### 示例\n\n现在我们来演示一下：发送一个POST请求到https://postman-echo.com/post。\n\n1. 选择POST方法\n2. 输入url：`https://postman-echo.com/post`\n3. 使用默认HTTP版本：http 1.1\n4. 编辑请求header\n   ```http\n   User-Agent: Fiddler\n   Content-Type: application/form-data\n   Host: postman-echo.com\n   ```\n5. 编辑请求body\n   ```http\n   hello world!!!\n   ```\n6. 点击execute执行请求\n\n![](/img/2018-08-08 013221.jpg)\n\n结果是运行成功。可以在session list中看到我们发送了一条请求，在inspectors中查看详情：\n\n![](/img/2018-08-08 014354.png)\n\n#### 1.2 Raw\n\nComposer中的第2个tab是Raw。我们可以在Raw中编写原始的http请求协议，然后点击execute发送请求。一般我们都不会这么编写吧...\n\n如图，在Raw中编写原始http请求：\n\n![](/img/2018-08-08 014844.jpg)\n\n运行结果与上面使用parsed的示例中结果是一样的。\n\n此外，Raw界面也支持直接把session拖拽进来运行。\n\n#### 1.3 Scratchpad\n\nComposer中的第3个tab是Scratchpad。正如它的中文意思：便签簿。这里可以储存你的请求。每个请求之间用“=========”来分开。你可以自己输入Raw格式的http请求，也可以直接从左边的会话中拖拽进来。\n\n如果要运行一个请求：用鼠标划选一个请求（注意不要把====分隔符也选中了），然后点击execute就可以运行了。\n\n![](/img/2018-08-08 020214.jpg)\n\n#### 1.4 Options\n\nComposer中的第4个tab是Options。这里是设置一些选项的地方。\n\n![](/img/2018-08-08 022443.jpg)\n\n分为`Request 选项`和`UI 选项`。\n\nRequest 选项：\n- inspect session：如果勾选了这一项，那么在执行请求的时候，会自动切换到inspector界面。\n- fix content-length header:勾选此项，会在你发送请求的时候帮你在请求头中修改content-Length属性（如果没有就创建），以匹配请求主体的大小。\n- follow redirects：勾选此项，会跟随重定向。\n- automactically authenticate：勾选此项，导致 Fiddler 自动响应 http / 401和 http / 407的挑战，这些挑战使用 NTLM 或协商协议使用当前用户的 Windows 凭据（原文：causes Fiddler to automatically respond to HTTP/401 and HTTP/407 challenges that use NTLM or Negotiate protocols using the current user's Windows credentials.）\n\nUI 选项：点击里面的“tear off”按钮，会把Composer作为一个独立的窗口运行。\n\n### 2 最后\n\n以上就是使用fiddler发送请求的介绍了。后续再介绍fiddler修改请求吧~\n\n---\n\nNow：2018年8月8日02:29:18\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=481519556&auto=1&height=66\"></iframe>\n","tags":["fiddler"]},{"title":"Python之OS模块【二】","url":"/2018/08/03/Python之OS模块【二】/","content":"\n### 0 前言\n\n上一篇文章介绍了os模块中os.path的使用。这篇文章我们来讲解os模块的使用。主要介绍使用os模块完成对系统文件的操作。os中很多常用方法的功能类似linux中命令：ls、pwd、cd、mkdir、rmdir、chown、chmod、等等...\n接下来简单介绍os模块中一些属性和常用的方法。\n\n---\n\n### 1 常用属性\n\n#### 1.1 os.name \n\nos.name可以表示当前操作系统类型。其实它是导入的操作系统相关模块的名称。比如：`os.name = \"posix\"`表示linux系统，`os.name = \"nt\"`表示window系统。\n\n示例代码如下(我在window下演示)：\n\n```python\n#  os.name表示当前系统名\nprint(os.name)   \n```\n运行结果：\n```shell\nnt\n```\n\n#### 1.2 os.environ\n\nos.environ是一个储存系统环境变量的mapping对象。可以使用`os.environ[\"系统环境变量的key\"]`来使用特定的变量。\n\n代码示例如下：\n\n```python\n#  查看环境变量。environ是一个mapping类型对象，保\nprint(os.environ)                \n#  例如使用environ[\"homepath\"]查看主目录名称\nprint(os.environ['homepath'])    \nprint(os.environ['classpath'])    \n```\n运行结果：\n```Python\nenviron({'ALLUSERSPROFILE': 'C:\\\\ProgramData', 'ANT_HOME': 'D:\\\\apache-ant-1.10.3', 'APPDATA': 'C:\\\\Users\\\\dar\\\\AppData\\\\Roaming', 'CLASSPATH': '.;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\lib;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\lib\\\\dt.jar;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\lib\\\\tools.jar;D:\\\\apache-ant-1.10.3\\\\lib', 'COMMONPROGRAMFILES': 'C:\\\\Program Files\\\\Common Files', 'COMMONPROGRAMFILES(X86)': 'C:\\\\Program Files (x86)\\\\Common Files', 'COMMONPROGRAMW6432': 'C:\\\\Program Files\\\\Common Files', 'COMPUTERNAME': 'DESKTOP-EPNA62A', 'COMSPEC': 'C:\\\\Windows\\\\system32\\\\cmd.exe', 'HOMEDRIVE': 'C:', 'HOMEPATH': '\\\\Users\\\\dar', 'JAVA_HOME': 'C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131', 'LOCALAPPDATA': 'C:\\\\Users\\\\dar\\\\AppData\\\\Local', 'LOGONSERVER': '\\\\\\\\DESKTOP-EPNA62A', 'MYSQL_HOME': 'C:\\\\Program Files\\\\MySQL\\\\MySQL Server 8.0', 'NUMBER_OF_PROCESSORS': '4', 'ONEDRIVE': 'C:\\\\Users\\\\dar\\\\OneDrive', 'OS': 'Windows_NT', 'PATH': 'D:\\\\python\\\\Scripts\\\\;D:\\\\python\\\\;D:\\\\apache-ant-1.10.3\\\\bin;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\bin;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\jre\\\\bin;C:\\\\Windows/system32;C:\\\\Windows;D:\\\\Node.js\\\\;C:\\\\Program Files\\\\MySQL\\\\MySQL Server 8.0\\\\bin;D:\\\\Microsoft VS Code\\\\bin;C:\\\\Users\\\\dar\\\\AppData\\\\Roaming\\\\npm;C:\\\\Users\\\\dar\\\\AppData\\\\Local\\\\GitHubDesktop\\\\bin', 'PATHEXT': '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW', 'PROCESSOR_ARCHITECTURE': 'AMD64', 'PROCESSOR_IDENTIFIER': 'Intel64 Family 6 Model 60 Stepping 3, GenuineIntel', 'PROCESSOR_LEVEL': '6', 'PROCESSOR_REVISION': '3c03', 'PROGRAMDATA': 'C:\\\\ProgramData', 'PROGRAMFILES': 'C:\\\\Program Files', 'PROGRAMFILES(X86)': 'C:\\\\Program Files (x86)', 'PROGRAMW6432': 'C:\\\\Program Files', 'PSMODULEPATH': 'C:\\\\Windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules\\\\', 'PUBLIC': 'C:\\\\Users\\\\Public', 'PYCHARM_HOSTED': '1', 'PYCHARM_MATPLOTLIB_PORT': '60789', 'PYTHONIOENCODING': 'UTF-8', 'PYTHONPATH': 'D:\\\\PyCharm 2018.2\\\\helpers\\\\pycharm_matplotlib_backend;E:\\\\PycharmProjects', 'PYTHONUNBUFFERED': '1', 'SESSIONNAME': 'Console', 'SYSTEMDRIVE': 'C:', 'SYSTEMROOT': 'C:\\\\Windows', 'TEMP': 'C:\\\\Users\\\\dar\\\\AppData\\\\Local\\\\Temp', 'TMP': 'C:\\\\Users\\\\dar\\\\AppData\\\\Local\\\\Temp', 'USERDOMAIN': 'DESKTOP-EPNA62A', 'USERDOMAIN_ROAMINGPROFILE': 'DESKTOP-EPNA62A', 'USERNAME': 'dar', 'USERPROFILE': 'C:\\\\Users\\\\dar', 'WINDIR': 'C:\\\\Windows'})\n\\Users\\dar.;C:\\Program Files\\Java\\jdk1.8.0_131\\lib;C:\\Program Files\\Java\\jdk1.8.0_131\\lib\\dt.jar;C:\\Program Files\\Java\\jdk1.8.0_131\\lib\\tools.jar;D:\\apache-ant-1.10.3\\lib\n```\n\n### 2 常用方法\n为了方便演示，先创建一个路径：./aaa/bbb/ccc/ddd.py\n#### 2.1 os.access(path,mode)\n\naccess方法用来判断对path的权限。mode可选不同的权限：存在F_OK、可读R_OK、可写W_OK、可执行X_OK。 方法返回一个bool值\n\n演示代码：\n\n```Python\nprint(os.access(path, os.F_OK))  \nprint(os.access(path, os.R_OK))  \nprint(os.access(path, os.W_OK))  \nprint(os.access(path, os.X_OK))  \n```\n\n运行结果：\n\n```shell\nTrue\nTrue\nTrue\nTrue\n```\n#### 2.2 os.getcwd()\ngetcwd方法返回当前工作目录的字符串\n\n演示代码：\n```python\nprint(os.getcwd()) \n```\n\n运行结果：\n```shell\nE:\\PycharmProjects\\practise_20180731\n```\n\n#### 2.3 os.chdir(path)\n\nchdir将当前工作目录更改为path。\n\n演示代码：\n```python\n#  转跳到上一个目录\nos.chdir(path+\"/../\")\nprint(os.getcwd())  \n```\n\n运行结果如下\n```shell\nE:\\PycharmProjects\\practise_20180731\\aaa\\bbb\\ccc\n```\n另外：os.chroot(path)表示工作路径的根目录变为path。可以自行实验一下。\n\n#### 2.4 os.chmod(path,mode)\nchmod将path的模式修改为mode，类比一下linux命令中的`chmod ./test.txt 777`。\n\n虽然Windows支持 chmod()，但只能使用它设置文件的只读标志（通过 stat.S_IWRITE 和 stat.S_IREAD 常量或相应的整数值）。所有其他位被忽略。\n\n演示代码：\n```python\nos.chdir(\"../../../\")           \nos.chmod(path, 775)             \nprint(os.access(path, os.F_OK)) \nprint(os.access(path, os.R_OK)) \nprint(os.access(path, os.W_OK)) \nprint(os.access(path, os.X_OK)) \n```\n\n运行结果：\n```shell\nTrue\nTrue\nFalse\nTrue\n```\n\n#### 2.5 os.chown(path, uid, gid)\n将 path 的所有者和组ID更改为数字 uid 和 gid。要保留其中一个id，请将其设置为-1。有关接受除数字ID之外的名称的更高级别函数，请参阅 shutil.chown()。shutil是另一个模块。\n\n#### 2.6 os.listdir(path)\nlistdir返回包含 path 给出的目录中条目名称的列表。该列表是任意顺序，并且不包括特殊条目 '.' 和 '..'。\n\n演示代码：\n```python\nprint(os.listdir(\"./\"))\n```\n运行结果：\n```shell\n['aaa', 'ddd.py', 'eee.py', 'os.path_test.py', 'os_test.py', '__init__.py']\n```\n\n另外：os.scandir() 函数返回目录条目以及文件属性信息。函数返回一个迭代器对象。\n\n下面示例显示了简单使用 scandir() 来显示给定 path 中不以 '.' 开头的所有文件（不包括目录）。 entry.is_file() 呼叫通常不会进行额外的系统调用。演示代码：\n```python\nwith os.scandir(\"./\") as it:\n    for entry in it:\n        if not entry.name.startswith('.') and entry.is_file():\n            print(entry.name)\n```\n运行结果：\n```shell\nos.path_test.py\nos_test.py\n__init__.py\n```\n\n#### 2.7 os.mkdir(path, mode)\nos.mkdir创建一个名为 path 的数字模式为 mode 的目录。如果目录已经存在，则抛出FileExistsError。\n\n演示代码：\n```python\nprint(os.listdir(\"./\"))\nos.mkdir(\"test_mkdir\", 775)\nprint(os.listdir(\"./\"))\n```\n\n运行结果：\n```python\n['aaa', 'ddd.py', 'eee.py', 'os.path_test.py', 'os_test.py', '__init__.py']\n['aaa', 'ddd.py', 'eee.py', 'os.path_test.py', 'os_test.py', 'test_mkdir', '__init__.py']\n```\n另外：如果想递归生成目录，请使用os.makedirs()\n\n#### 2.8 os.rmdir(path)\nos.rmdir能删除空目录path，如果不是空的会报错。\n\n演示代码：\n```python\nprint(os.listdir(\"./\"))\nos.rmdir(\"test_mkdir\")\nprint(os.listdir(\"./\"))\n```\n\n运行结果：\n```python\n['aaa', 'ddd.py', 'eee.py', 'os.path_test.py', 'os_test.py', 'test_mkdir', '__init__.py']\n['aaa', 'ddd.py', 'eee.py', 'os.path_test.py', 'os_test.py', '__init__.py']\n```\n\n另外：\n- os.remove(path)删除文件，如果path是目录则报错；\n- os.removedirs()递归删除空目录,如果叶子节点目录非空则报错，后面遇到非空目录时会停下；\n- 为了删除整个目录树，可以使用 shutil.rmtree()。\n\n#### 2.9 os.rename(src, dst)\nos.rename重命名文件或目录，src是文件名且dst是新文件名，src是目录名且dst是新目录名，其他情况报错。\n\n#### 2.10 os.system(command)\nos.system函数输入一个命令行指令，然后会返回运行结果到标准输出流，函数return值为命令行窗口返回的值。\n\n演示代码：\n```python\n#  ping百度的网址，然后打印命令窗口的返回值\nprint(os.system(\"ping www.baidu.com\"))\n```\n\n运行结果(因为window系统的命令行汉字编码和pycharm文件编码不一样，所以出现了乱码...但是功能还是实现了的嘛= =)：\n```python\n���� Ping www.baidu.com [163.177.151.109] ���� 32 �ֽڵ�����:\n���� 163.177.151.109 �Ļظ�: �ֽ�=32 ʱ��=3ms TTL=53\n���� 163.177.151.109 �Ļظ�: �ֽ�=32 ʱ��=4ms TTL=53\n���� 163.177.151.109 �Ļظ�: �ֽ�=32 ʱ��=3ms TTL=53\n���� 163.177.151.109 �Ļظ�: �ֽ�=32 ʱ��=4ms TTL=53\n\n163.177.151.109 �� Ping ͳ����Ϣ:\n    ���ݰ�: �ѷ��� = 4���ѽ��� = 4����ʧ = 0 (0% ��ʧ)��\n�����г̵Ĺ���ʱ��(�Ժ���Ϊ��λ):\n    ��� = 3ms��� = 4ms��ƽ�� = 3ms\n0\n```\n我在网上查找了一些解决方法。pycharm默认使用utf-8编码，而window命令行一般是用gbk编码，因此建议是修改file encoding。不过我试了一下好像没什么效果...如果有同学找到了解决方法记得留言呀~\n\n另外：subprocess 模块提供了更强大的功能，用于生成新进程和检索其结果；使用该模块比使用此功能更可取。有关一些有用的配方，请参阅 subprocess 文档中的 使用 subprocess 模块替换旧功能 部分。\n\n### 3 其他\n关于os模块的介绍就到这里了，一般常用的方法大概都讲解到了。如果遇到一些其他方法，可以通过查看源码的方式学习！记住，查看源码是最好的学习方式~.\n\n下一篇文章，我们开始学习subprocess模块————子进程模块。到时候有更好的方法调用系统的命令行窗口，实现与命令行窗口的交互...\n\n\n\n>最后让一首歌结束今天的内容~~~\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=298 height=52 src=\"//music.163.com/outchain/player?type=2&id=479979076&auto=0&height=32\"></iframe>","tags":["python"]},{"title":"Python之OS模块【一】","url":"/2018/08/01/Python之OS模块【一】/","content":"\n## 0 前言\n\n学习了一定的python语言基础后，我们开始学习一些Python标准库中的常用模块。本次介绍OS模块。OS模块主要用于程序与操作系统之间的交互。\nOS模块使得我们能用相同的代码与不同的操作系统交互。因为OS模块帮我们透明化了不同操作系统的差异。比如我们可使用os.path中的方法对操作系统进行路径操作，不用担心window、linux、mac操作系统路径语法的差异。\nos.path这个对象其实是根据不同操作系统导入了不同的路径操作模块（ntpath.py、posixpath.py）\n\n![](/img/2018-08-01 111351.png)\n\n这段os.py中的源码展示了如何根据不同的操作系统，执行 `improt ntpath as path`还是`import posixpath as path`，这样对我们来说，不管是linux还是window，我们只要使用path就可以了。os模块正是通过这种方式统一了接口。\n\n这篇文章先来讲解os模块中os.path的使用。\n\n---\n\n## 1 os.path\n\nos.path模块对路径操作实现一些有用的功能。\n\n### 1.1 导入os模块\n\nos.path是通过os模块来导入的。像之前解释的，os.path本质上是ntpath或者posixpath模块，只不过os模块中帮我们导入了ntpath或者posixpath模块。\n\n在代码中输入下面的代码导入模块：\n```python\nimport os\n```\n此外，为了方便演示，我在我的project文件中先创建了一些文件路径：\n\n![](/img/2018-08-01 112710.png)\n\n我用来演示的py文件名为os_test.py。\n\n创建了文件路径后，我们在代码中定义一个字符串变量`path`来表示这个路径\n```python\n#  演示用的路径\npath = \"aaa/bbb/ccc/ddd.py\"\n```\n\n### 1.2 常用函数介绍\n\n接下来介绍os.path中常用的函数。想全面的了解，最好的办法还是阅读源码和官方文档。\n>源码：可以在pychram中打开源码查看\n\n>官方文档：https://docs.python.org/3/library/os.path.html\n\n>一些翻译成中文的文档：\n> - https://yiyibooks.cn/xx/python_352/index.html;\n>- https://www.rddoc.com/doc/Python/3.6.0/zh/library/os.path/\n\n#### exists(path)\n\nexists函数判断path是否存在。返回bool类型。\n\n```python\nprint(os.path.exists(path))\nprint(os.path.exists(\"/aaa/bbb/ccc\"))\n```\n运行结果：\n\n```python\nTrue\nFalse\n```\n\n#### abspath(path)\n\nabspath函数返回一个标准的path路径的绝对路径。\n\n```python\nprint(os.path.abspath(path))\n```\n运行结果：\n\n```python\nD:\\PycharmProjects\\practise_20180731\\aaa\\bbb\\ccc\\ddd.py\n```\n\n#### split(path)\n\nsplit函数将path拆分成dirname和basename,返回二元元组\n\n```python\nprint(os.path.split(path))\n```\n运行结果：\n\n```python\n('aaa/bbb/ccc', 'ddd.py')\n```\n\n#### dirname(path)\n\ndirname函数返回path的目录名。实际上是通过将path参数传递个 split()函数得到的返回值的第一个元素.\n\n```python\nprint(os.path.dirname(path))\n```\n运行结果：\n\n```python\naaa/bbb/ccc\n```\n\n#### basename(path)\n\n返回路径名path的最后一级的名称。它为将path参数传递给split()函数返回的元组对的第二个元素。请注意，这个函数的结果不同于Unix的basename程序；对于'/foo/bar/'，Unix的basename返回'bar'，而basename()函数返回空字符串（''）。\n\n```python\nprint(os.path.basename(path))\n```\n运行结果：\n\n```python\nddd.py\n```\n\n#### getsize(path)\n\n返回path的大小，以字节为单位。如果文件不存在或无法访问，则引发OSError。\n\n```python\nprint(os.path.getsize(path))\n```\n运行结果：\n\n```python\n50\n```\n\n#### getatime(path),getctime(path),getmtime(path)\n\ngetatime, getctime, getmtime三个函数分别返回文件的最后访问、创建、修改时间，path无效则抛出OSError\n可以使用time.gmtime()来以struct_time形式输出最近修改时间（不过要额外导入time模块`import time`）\n\n```python\nprint(os.path.getatime(path))\nprint(time.gmtime(os.path.getatime(path)))\nprint(time.gmtime(os.path.getctime(path)))\nprint(time.gmtime(os.path.getmtime(path)))\n```\n运行结果：\n\n```python\n1533089540.9916\ntime.struct_time(tm_year=2018, tm_mon=8, tm_mday=1, tm_hour=2, tm_min=12, tm_sec=20, tm_wday=2, tm_yday=213, tm_isdst=0)\ntime.struct_time(tm_year=2018, tm_mon=8, tm_mday=1, tm_hour=2, tm_min=11, tm_sec=51, tm_wday=2, tm_yday=213, tm_isdst=0)\ntime.struct_time(tm_year=2018, tm_mon=8, tm_mday=1, tm_hour=2, tm_min=12, tm_sec=20, tm_wday=2, tm_yday=213, tm_isdst=0)\n```\n\n#### isabs,isfile,isdir,islink,ismount\n\nisabs,isfile,isdir,islink,ismount函数分别判断path是否为绝对路径，常规文件，文件夹，链接，挂载点\n\n```python\nprint(os.path.isabs(path))\nprint(os.path.isfile(path))\nprint(os.path.isdir(path))\nprint(os.path.islink(path))\nprint(os.path.ismount(path))\n```\n运行结果：\n\n```python\nFalse\nTrue\nFalse\nFalse\nFalse\n```\n\n#### commonpath(paths)、commonprefix(list)\n\ncommonpath返回paths参数序列中，所有路径序列中共有的最长的路径.如果 paths 即包含绝对路径又包含相对路径,或者 paths 为空将抛出ValueError.不同于 commonprefix()函数, commonpath()返回一个有效的路径.\n\ncommonprefix返回列表中所有路径的前缀的最长路径前缀（逐个字符）。如果列表为空，则返回空字符串（''）。此函数可能返回无效路径，因为它一次处理一个字符。要获取有效路径，请参阅commonpath()。\n\n```python\nprint(os.path.commonpath([\"/aaa/bbb\", \"/aaa/bbb/ccc\"]))\n\nprint(os.path.commonprefix([\"/aaa/bbb\", \"/aaa/bbb/ccc\"]))\nprint(os.path.commonprefix([\"\"]))\nprint(os.path.commonprefix([\"/aaa/bbc\", \"/aaa/bbb/ccc\"]))\n```\n运行结果：\n\n```python\n\\aaa\\bbb\n/aaa/bbb\n\n/aaa/bb\n```\n\n## 2 其他\n\n下一篇文章将会介绍os模块的其他功能，比如：新建、删除、重命名、查询文件或文件夹 还有调用系统命令等","tags":["python"]},{"title":"二、【fiddler】的界面与抓包","url":"/2018/07/30/fiddler的界面介绍/","content":"\n### 0 前言\n\n上一篇中介绍了fiddler的安装与配置，这一篇文章将对fiddler的界面进行介绍。以及查看抓取的数据包。\n\n---\n\n### 1 开启抓取网络会话\n\n在Fiddler中，勾选上File->Capture Traffic 或者在左下角点击Capturing，就可以开始抓包啦！如果你要抓取https协议包，记得做好相关的配置，具体可以查看上一篇文章。\n\n第一种方法\n![](/img/2018-07-31 095221.png)\n\n第二种方法\n![](/img/2018-07-31 095331.png)\n\n如果完成了上述操作，还不能抓到包，可能是你其他地方没有设置好，可以检查浏览器是否启用了代理、在filter中查看是否启用了过滤器（我自己演示的时候，就是忘了关掉过滤器导致半天都没抓到包...）等\n\n![](/img/2018-07-31 095701.jpg)\n\n如果你操作正常，应该就可以在会话列表中看到数据包了：\n\n![](/img/2018-07-31 095857.jpg)\n\n### 2 查看网络会话\n\n#### 2.1 查看网络会话详细信息\n\n在会话列表中，以表格的形式给我们展现了所有抓到的数据包，展示的信息有：id号、响应码、协议名、域名、数据格式、url、传输数据大小、缓存类型、进程、备注等。这些表头可以通过拖动来自定义顺序和行宽。\n\n![](/img/2018-07-31 100542.jpg)\n\n#### 2.1 查看网络会话统计信息\n\n我们可以在Statistics中查看网络会话的信息统计（主要是对时间、空间的统计）：\n\n1. 在会话列表点击选中1或多个会话\n2. 在右边点击Statistics \n  \n![](/img/2018-07-31 100928.png)\n\n#### 2.2 分析网络会话\n\n我们可以在Inspectors中查看网络会话的数据内容,inspectors中的信息是我们工作中查看的主要内容。\n\n1. 点击选中一个会话\n2. 点击右边的Inspectors\n   \n![](/img/2018-07-31 101557.jpg)\n\n我们看看界面的右边，上半部分是请求request的信息，可以查看请求头header、请求主体textview、表单webforms、cookies、json格式查看等。下半部分是响应response的信息，可以查看响应头、响应主体、以图片、网页、json、xml、raw等格式查看响应的消息内容。\n\n#### 2.3 查看网络会话的传输耗时\n\n使用Timeline查看1或者多个会话的传输耗时\n\n1. 在会话列表选中1或多个会话\n2. 点击右边的Timeline栏\n  \n![](/img/2018-07-31 102524.jpg)\n\n### 3 查找与过滤会话\n\n#### 3.1 查找会话\n\n有时候，抓到的数据包太多，在这么多会话中找到我们要分析的那个是比较麻烦的。fiddler给我们提供了一个find功能，用来搜索特定的会话。\n\n##### 3.1.1 使用find选项框\n\n点击find会弹出一个对话框，我们可以在find文本框中输入要搜索的文本。下方的options中可以进行高级设置。找到符合条件的会话，会通过高亮的方式标记显示。\n\n![](/img/2018-07-31 104439.png)\n\n##### 3.1.2 使用命令行QuickExec\n\nfiddler提供了一个命令行工具，后面会专门学习命令行的使用。我们可以使用命令行来查找特定会话。\n命令行是在左下角的一个黑框。输入`?sometext`即可搜索和'sometext'相关的会话。\n\n![](/img/2018-07-31 105420.png)\n\n#### 3.2 过滤会话\n\n除了用find，还有一种方便我们查看会话的方法，就是使用过滤filter功能。在右侧菜单中，找到Fittlers选项，共有9个部分进行设置。\n\n![](/img/2018-07-31 105841.png)\n\n1. Use Filters：勾选则表示使用过滤，不勾选则表示不进行过滤\n2. Actions：有四个选项，Run Filterset now：立即运行过滤设置；Load Filterset：加载保存的过滤设置；Save Filterset：保存过滤设置；help：帮助\n3.  Hosts：该设置项有两个选项\n   - 第一个下拉框是只显示内网或者外网选项\n  ![](/img/2018-07-31 110028.png)\n   - 第二个下拉框是根据主机名信息显示或者隐藏或者标记指定请求\n  ![](/img/2018-07-31 110124.png)\n4. Client Process：有三个选项，Show only traffic from：根据进程信息进行过滤，选择后，将只显示由该进程发出的请求；Show only Internet Explorer traffic：只关心由IE浏览器发出的请求；Hide traffic from Service Host：隐藏来自service host（即由svchost.exe进程发出）的请求\n5. Request Headers：有五个选项，Show only if URL contains：可以通过正则表达式过滤请求地址中包含或不包含的内容，例如REGEX:\\.(js|css|js\\?.*|css\\?.*)$（隐藏所有js和css请求）；Hide if URL contains：与Show only if URL contains相反，一个是显示，一个是隐藏；Flags requests with headers：支持指定某个http请求头名称，如果在web session列表中存在该请求头，会加粗显示该session；Delete requests headers：与Flags requests with headers类似，这里是如果包含该请求头，则删除该请求头；Set request header：将HTTP请求头更新为所输入的值。\n6. Breakpoints：断点设置，有四个选项。Break request on POST：对POST请求设置断点；Break request on GET with query string：会为所有方法为GET且URL中包含了给定查询条件的请求设置断点；Break on XMLHttpRequest：对所有能够确定是通过XMLHTTPRequest对象发送的请求设置断点；Break response on Content-Type：会为所有响应头Content-Type中包含了指定文本的响应设置响应断点。\n7. Response Status Code：根据响应状态码设置断点。\n8. Response Type and Size：有几种类型，一类是根据响应数据的类型显示或隐藏；一类是根据响应数据的大小显示或隐藏；一类是根据响应所需要的时间设置背景颜色；一类是根据文件类型进行限制。\n   - type有以下几种类型：\n  ![](/img/2018-07-31 110304.png)\n   - Time HeatMap复选框会基于服务器返回给定响应所需要的时间为每个session设置背景颜色。\n9. Response Headers：与Request Headers不同的是，这块区域是针对响应数据的头部进行过滤。\n\n这么多设置项，比较常用的就是1.2.3部分。通过过滤设置，可以快速的帮助我们找到我们需要抓包分析的数据包，从而提高效率，避免过多的数据包信息干扰我们找到正确的数据包。\n\n#### 3.3 比较两个会话\n\n选中会话list中的多个会话，然后右键点击，选择comprare。\n\n![](/img/2018-07-31 112249.png)\n\n可能你点击compare之后会弹出错误提示框，别慌，往下看：\n\n##### 3.3.1 安装插件来比较会话\n\n默认情况下，fiddler尝试打开windiff或者winmerge来比较两个会话，不过默认没有安装这些插件，需要我们自行下载...我没有使用这些插件。如果需要，可以点击参考[这个](https://support.microsoft.com/zh-cn/help/159214/how-to-use-the-windiff-exe-utility)文档进行下载安装。\n\n##### 3.3.2 更改默认文本比较工具\n\n如果你电脑有一些比较高级的编辑器，可以使用这些编辑器来来比较两个会话。不过使用之前，我们要改变fiddler默认的文本比较工具。\n\n1. 点击Tools->Fiddler Options->Tools\n2. 找到你编辑器的程序路径即可。\n\n![](/img/2018-07-31 112504.png)\n\n### 3 其他\n\n使用fiddler查看网络数据包就先介绍到这里，欢迎补充！下一篇我们将学习如何截获并且修改网络请求和响应~","tags":["fiddler"]},{"title":"一、【fiddler】的安装与配置","url":"/2018/07/30/fiddler的安装与配置/","content":"\n### 0 前言\n\nFiddler是最强大最好用的Web调试工具之一，它能记录所有客户端和服务器的http和https请求，允许你监视，设置断点，甚至修改输入输出数据，Fiddler包含了一个强大的基于事件脚本的子系统，并且能使用.net语言进行扩展。你对HTTP 协议越了解， 你就能越掌握Fiddler的使用方法。你越使用Fiddler，就越能帮助你了解HTTP协议。Fiddler无论对开发人员或者测试人员来说，都是非常有用的工具。\n\n之前了解了fiddler的基本使用方法。在补充复习fiddler知识的基础上，进一步学习fiddler的使用。\n\n想要全面的学习fiddler，最好的方式还是看[官方文档](https://docs.telerik.com/fiddler/Configure-Fiddler/)来学习。如果官网的网页太慢，可以观看在github上开源的文档。我把开源库fork到了我的github上。点击[这里](https://github.com/Ngwind/fiddler-docs)查看。\n\n---\n\n### 1 fiddler的工作原理\n\nFiddler 是以代理web服务器的形式工作的，它使用代理地址:127.0.0.1，端口:8888。当Fiddler退出的时候它会自动注销，这样就不会影响别的程序。不过如果Fiddler非正常退出，这时候因为Fiddler没有自动注销，会造成网页无法访问。解决的办法是重新启动下Fiddler。\n\n![fiddler代理](/img/2018-07-30 162723.png)\n\n### 2 下载Fiddler\n\n在[官网](https://www.telerik.com/fiddler)上下载最新的Fiddler安装包。最好下载高版本的，之前我下载安装的是Fiddler2，然后里面有些功能（比如Fiddler Script功能）还要安装插件。\n\n在官网找到Free download按钮，点击进入下载页面。下载前，它会让你填写一下基本信息，随便填写好之后，就可以下载了。\n\n### 3 安装Fiddler\n\n一般下载的是一个.exe的可执行文件，下载好安装包之后，点击FiddlerSetup.exe开始安装。点击同意使用协议->选择安装路径（尽量别安装在C盘）->点击开始安装，稍等片刻就安装完成了。\n\n### 4 使用之前\n\nFiddler代理服务器是安装在Fiddler中的，它作为中间人，抓取客户端发送的数据包，然后转发到真正的请求服务器；服务器向fiddler代理服务器返回响应数据包，然后fiddler代理服务器再转发给客户端。一些特殊的场景需要我们进行配置比如：解析Https数据包、使用通道绑定令牌进行身份验证等\n\n#### 4.1 解析Https数据包\n\n第一步，点击选项栏的Tools->Options->Https.\n\n第二步，勾选Decrypt HTTPS Traffic，前提是确保你勾选了Capture Https connects。\n\n![](/img/2018-07-30 165127.png)\n\n此外，可以在下方的文本框里输入域名，来跳过特定网址的https解析。\n\n![](/img/2018-07-30 165420.png)\n\n#### 4.2 浏览器抓包\n\nfiddler默认是在本机的8888端口监听数据包，所以要想能够抓到浏览器发出的包，需要我们在浏览器的设置中配置好代理（ip是本机ip：127.0.0.1，端口默认8888）。有些浏览器可能会自动设置好代理，比如IE浏览器、谷歌浏览器等。\n\n#### 4.3 移动设备抓包\n\nfiddler也可以抓取移动设备上的数据包，前提是你使用fiddler的电脑和移动设备要在同一个局域网中。我们一般通过手机连接wifi来抓包。这时需要我们给移动设备安装证书。\n\n##### 4.3.1 fiddler中的设置\n\n1. 点击Tools > Fiddler Options > Connections.\n\n2. 勾选 Allow remote computers to connect. \n   ![](/img/2018-07-30 170837.png)\n\n3. 然后重启fiddler\n\n4. fiddler右上角有个Online的电脑图标，把鼠标移到上面，会显示fiddler服务器的IP地址。记得这个IP地址，稍后会用上。\n   ![](/img/2018-07-30 171035.png)\n\n##### 4.3.2 移动设备中的设置\n\n1. 打开wifi，连接上局域网wifi。\n2. 选择修改wifi网络，把代理改为手动\n3. 设置代理ip地址为fiddler服务器的地址，端口号默认8888。可以在fiddler->Tools->connections中查看端口号。\n4. 设置完成后记得点击保存。\n5. 可以用手机浏览器访问`你的fiddler的ip地址:端口号`进行验证。这时fiddler中应该可以看到手机发送的数据包。\n\n##### 4.3.3 解析手机发送的https包\n\n想要抓取到手机端发送的https协议包，我们还要进行一些操作\n\n用手机浏览器访问`你的fiddler的ip地址:端口号`，点击页面中的FiddlerRoot certificate.这时会让你下载根证书，接受下载即可。\n下载完成后，在手机的设置中安装证书（具体手机安装证书的地方不一样）。安装好之后，应该就可以抓取到手机中的https协议包了。\n\n#### 4.4 其他\n\n在使用完fiddler后，记得到代理设置里面取消代理。\n","tags":["fiddler"]},{"title":"markdown语法示例","url":"/2018/07/30/markdown语法示例/","content":"# 目录\n\n* [1.语法示例](#1)\n\n* [1.1图片](#1.1)\n\n  * [1.1.1添加附件](#1.1)\n\n* [1.2换行](#1.2)\n\n* [1.3强调](#1.3)\n\n* [1.4引用](#1.4)\n\n<h2 id=\"1\">1.语法示例</h2>\n这是第一个标题下的文本,下面是将会是一个代码块：\n\n```python\na = \"hello world\"\nb = [\"a\", \"b\", \"c\"]\nprint(a)\n```\n\n`print(\"hello world\")`\n\n<h3 id=\"1.1\">1.1图片</h3>\n\n下面是一张来自百度的图片\n![pt](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1532586215&di=36b4f6bca2f07d72cd81d68b523d83fd&src=http://a2.att.hudong.com/26/50/01300000329092123781509550216.jpg)\n\n<h4 id=\"1.1.1\">1.1.1添加图片附件展示</h4>\n![baidu_log](./baidu_logo.png)\n\n<h3 id=\"1.2\">1.2换行</h3>\n\n这是第一段第二节\n\n这是第一段第二节\n\n这是第一段第二节\n\n这是第一段第二节\n\n这是第一段第二节\n\n<h3 id=\"1.3\">1.3强调</h3>\n\n***\n***\n***\n下面将实验一个链接，点击[这里](http://www.baidu.com)转跳到百度\n\n<h3 id=\"1.4\">1.4引用</h3>\n> www.baidu.com 这是引用\n","tags":["markdown"]},{"title":"markdown语法文档","url":"/2018/07/29/markdown语法文档/","content":">本文章来源：https://github.com/riku/Markdown-Syntax-CN/edit/master/syntax.md\n\n**NOTE:** This is Simplelified  Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to [Markdown: Syntax][eng-doc].\n\n[eng-doc]:http://daringfireball.net/projects/markdown/syntax\n\n**声明：** 这份文档派生(fork)于[繁体中文版](http://markdown.tw/)，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里[查看它的源文件][src1]。「繁体中文版的原始文件可以[查看这里][src] 。」--By @[riku][t]\n\n**注：** 本项目托管于 [GitHub][]上，请通过\"派生\"和\"合并请求\"来帮忙改进本项目。\n\n  [src1]: http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md\n  [src]: https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md\n  [t]: http://twitter.com/riku\n  [g]: http://gitcafe.com/riku/Markdown-Syntax-CN\n  [Github]: https://github.com/riku/Markdown-Syntax-CN\n  [GitCafe]: http://gitcafe.com/riku/Markdown-Syntax-CN/\n\nMarkdown 语法说明 (简体中文版) / ([点击查看快速入门](./basic.html))\n================\n\n*   [概述](#overview)\n    *   [宗旨](#philosophy)\n    *   [兼容 HTML](#html)\n    *   [特殊字符自动转换](#autoescape)\n*   [区块元素](#block)\n    *   [段落和换行](#p)\n    *   [标题](#header)\n    *   [区块引用](#blockquote)\n    *   [列表](#list)\n    *   [代码区块](#precode)\n    *   [分隔线](#hr)\n*   [区段元素](#span)\n    *   [链接](#link)\n    *   [强调](#em)\n    *   [代码](#code)\n    *   [图片](#img)\n*   [其它](#misc)\n    *   [反斜杠](#backslash)\n    *   [自动链接](#autolink)\n*   [感谢](#acknowledgement)\n*\t[Markdown 免费编辑器](#editor)\n\n* * *\n\n<h2 id=\"overview\">概述</h2>\n\n<h3 id=\"philosophy\">宗旨</h3>\n\nMarkdown 的目标是实现「易读易写」。\n\n可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 [Setext] [1]、[atx] [2]、[Textile] [3]、[reStructuredText] [4]、[Grutatext] [5] 和 [EtText] [6]，而最大灵感来源其实是纯文本电子邮件的格式。\n\n  [1]: http://docutils.sourceforge.net/mirror/setext.html\n  [2]: http://www.aaronsw.com/2002/atx/\n  [3]: http://textism.com/tools/textile/\n  [4]: http://docutils.sourceforge.net/rst.html\n  [5]: http://www.triptico.com/software/grutatxt.html\n  [6]: http://ettext.taint.org/doc/\n\n总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像\\*强调\\*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。\n\n<h3 id=\"html\">兼容 HTML</h3>\n\nMarkdown 语法的目标是：成为一种适用于网络的*书写*语言。\n\nMarkdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想*不是*要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种*发布*的格式，Markdown 是一种*书写*的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。\n\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。\n\n要制约的只有一些 HTML 区块元素――比如 `<div>`、`<table>`、`<pre>`、`<p>` 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 `<p>` 标签。\n\n例子如下，在 Markdown 文件里加上一段 HTML 表格：\n\n    这是一个普通段落。\n\n    <table>\n        <tr>\n            <td>Foo</td>\n        </tr>\n    </table>\n\n    这是另一个普通段落。\n\n请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的`*强调*`会没有效果。\n\nHTML 的区段（行内）标签如 `<span>`、`<cite>`、`<del>` 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 `<a>` 或 `<img>` 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。\n\n和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。\n\n<h3 id=\"autoescape\">特殊字符自动转换</h3>\n\n在 HTML 文件中，有两个字符需要特殊处理： `<` 和 `&` 。 `<` 符号用于起始标签，`&` 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 `&lt;` 和 `&amp;`。\n\n`&` 字符尤其让网络文档编写者受折磨，如果你要打「`AT&T`」 ，你必须要写成「`AT&amp;T`」。而网址中的 `&` 字符也要转换。比如你要链接到：\n\n    http://images.google.com/images?num=30&q=larry+bird\n\n你必须要把网址转换写为：\n\n    http://images.google.com/images?num=30&amp;q=larry+bird\n\n才能放到链接标签的 `href` 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。\n\nMarkdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 `&` 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 `&amp`;。\n\n所以你如果要在文档中插入一个版权符号 `©`，你可以这样写：\n\n    &copy;\n\nMarkdown 会保留它不动。而若你写：\n\n    AT&T\n\nMarkdown 就会将它转为：\n\n    AT&amp;T\n\n类似的状况也会发生在 `<` 符号上，因为 Markdown 允许 [兼容 HTML](#html) ，如果你是把 `<` 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：\n\n    4 < 5\n\nMarkdown 将会把它转换为：\n\n    4 &lt; 5\n\n不过需要注意的是，code 范围内，不论是行内还是区块， `<` 和 `&` 两个符号都*一定*会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 `<` 和 `&` 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）\n\n* * *\n\n<h2 id=\"block\">区块元素</h2>\n\n\n<h3 id=\"p\">段落和换行</h3>\n\n一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。\n\n「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 `<br />` 标签。\n\n如果你*确实*想要依赖 Markdown 来插入 `<br />` 标签的话，在插入处先按入两个以上的空格然后回车。\n\n的确，需要多费点事（多加空格）来产生 `<br />` ，但是简单地「每个换行都转换为 `<br />`」的方法在 Markdown 中并不适合， Markdown 中 email 式的 [区块引用][bq] 和多段落的 [列表][l] 在使用换行来排版的时候，不但更好用，还更方便阅读。\n\n  [bq]: #blockquote\n  [l]:  #list\n\n<h3 id=\"header\">标题</h3>\n\nMarkdown 支持两种标题的语法，类 [Setext] [1] 和类 [atx] [2] 形式。\n\n类 Setext 形式是用底线的形式，利用 `=` （最高阶标题）和 `-` （第二阶标题），例如：\n\n    This is an H1\n    =============\n\n    This is an H2\n    -------------\n\n任何数量的 `=` 和 `-` 都可以有效果。\n\n类 Atx 形式则是在行首插入 1 到 6 个 `#` ，对应到标题 1 到 6 阶，例如：\n\n    # 这是 H1\n\n    ## 这是 H2\n\n    ###### 这是 H6\n\n你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 `#`，而行尾的 `#` 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：\n\n    # 这是 H1 #\n\n    ## 这是 H2 ##\n\n    ### 这是 H3 ######\n\n\n<h3 id=\"blockquote\">区块引用 Blockquotes</h3>\n\nMarkdown 标记区块引用是使用类似 email 中用 `>` 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 `>` ：\n\n    > This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n    > consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n    > Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n    > \n    > Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n    > id sem consectetuer libero luctus adipiscing.\n\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 `>` ：\n\n    > This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n    consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n    > Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n    id sem consectetuer libero luctus adipiscing.\n\n区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 `>` ：\n\n    > This is the first level of quoting.\n    >\n    > > This is nested blockquote.\n    >\n    > Back to the first level.\n\n引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n\n\t> ## 这是一个标题。\n\t> \n\t> 1.   这是第一行列表项。\n\t> 2.   这是第二行列表项。\n\t> \n\t> 给出一些例子代码：\n\t> \n\t>     return shell_exec(\"echo $input | $markdown_script\");\n\n任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择*增加引用阶层*。\n\n<h3 id=\"list\">列表</h3>\n\nMarkdown 支持有序列表和无序列表。\n\n无序列表使用星号、加号或是减号作为列表标记：\n\n    *   Red\n    *   Green\n    *   Blue\n\n等同于：\n\n    +   Red\n    +   Green\n    +   Blue\n\n也等同于：\n\n    -   Red\n    -   Green\n    -   Blue\n\n有序列表则使用数字接着一个英文句点：\n\n    1.  Bird\n    2.  McHale\n    3.  Parish\n\n很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：\n\n    <ol>\n    <li>Bird</li>\n    <li>McHale</li>\n    <li>Parish</li>\n    </ol>\n\n如果你的列表标记写成：\n\n    1.  Bird\n    1.  McHale\n    1.  Parish\n\n或甚至是：\n\n    3. Bird\n    1. McHale\n    8. Parish\n\n你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。\n\n如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。\n\n列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。\n\n要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：\n\n    *   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n        Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\n        viverra nec, fringilla in, laoreet vitae, risus.\n    *   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\n        Suspendisse id sem consectetuer libero luctus adipiscing.\n\n但是如果你懒，那也行：\n\n    *   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\n    viverra nec, fringilla in, laoreet vitae, risus.\n    *   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\n    Suspendisse id sem consectetuer libero luctus adipiscing.\n\n如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 `<p>` \n标签包起来，举例来说：\n\n    *   Bird\n    *   Magic\n\n会被转换为：\n\n    <ul>\n    <li>Bird</li>\n    <li>Magic</li>\n    </ul>\n\n但是这个：\n\n    *   Bird\n\n    *   Magic\n\n会被转换为：\n\n    <ul>\n    <li><p>Bird</p></li>\n    <li><p>Magic</p></li>\n    </ul>\n\n列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：\n\n    1.  This is a list item with two paragraphs. Lorem ipsum dolor\n        sit amet, consectetuer adipiscing elit. Aliquam hendrerit\n        mi posuere lectus.\n\n        Vestibulum enim wisi, viverra nec, fringilla in, laoreet\n        vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\n        sit amet velit.\n\n    2.  Suspendisse id sem consectetuer libero luctus adipiscing.\n\n如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：\n\n    *   This is a list item with two paragraphs.\n\n        This is the second paragraph in the list item. You're\n    only required to indent the first line. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit.\n\n    *   Another item in the same list.\n\n如果要在列表项目内放进引用，那 `>` 就需要缩进：\n\n    *   A list item with a blockquote:\n\n        > This is a blockquote\n        > inside a list item.\n\n如果要放代码区块的话，该区块就需要缩进*两次*，也就是 8 个空格或是 2 个制表符：\n\n    *   一列表项包含一个列表区块：\n\n            <代码写在这>\n\n\n当然，项目列表很可能会不小心产生，像是下面这样的写法：\n\n    1986. What a great season.\n\n换句话说，也就是在行首出现*数字-句点-空白*，要避免这样的状况，你可以在句点前面加上反斜杠。\n\n    1986\\. What a great season.\n\n<h3 id=\"precode\">代码区块</h3>\n\n和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 `<pre>` 和 `<code>` 标签来把代码区块包起来。\n\n要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：\n\n    这是一个普通段落：\n\n        这是一个代码区块。\n\nMarkdown 会转换成：\n\n    <p>这是一个普通段落：</p>\n\n    <pre><code>这是一个代码区块。\n    </code></pre>\n\n这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：\n\n    Here is an example of AppleScript:\n\n        tell application \"Foo\"\n            beep\n        end tell\n\n会被转换为：\n\n    <p>Here is an example of AppleScript:</p>\n\n    <pre><code>tell application \"Foo\"\n        beep\n    end tell\n    </code></pre>\n\n一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\n\n在代码区块里面， `&` 、 `<` 和 `>` 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：\n\n        <div class=\"footer\">\n            &copy; 2004 Foo Corporation\n        </div>\n\n会被转换为：\n\n    <pre><code>&lt;div class=\"footer\"&gt;\n        &amp;copy; 2004 Foo Corporation\n    &lt;/div&gt;\n    </code></pre>\n\n代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。\n\n<h3 id=\"hr\">分隔线</h3>\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n    * * *\n\n    ***\n\n    *****\n\n    - - -\n\n    ---------------------------------------\n\n\n* * *\n\n<h2 id=\"span\">区段元素</h2>\n\n<h3 id=\"link\">链接</h3>\n\nMarkdown 支持两种形式的链接语法： *行内式*和*参考式*两种形式。\n\n不管是哪一种，链接文字都是用 [方括号] 来标记。\n\n要建立一个*行内式*的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：\n\n    This is [an example](http://example.com/ \"Title\") inline link.\n\n    [This link](http://example.net/) has no title attribute.\n\n会产生：\n\n    <p>This is <a href=\"http://example.com/\" title=\"Title\">\n    an example</a> inline link.</p>\n\n    <p><a href=\"http://example.net/\">This link</a> has no\n    title attribute.</p>\n\n如果你是要链接到同样主机的资源，你可以使用相对路径：\n\n    See my [About](/about/) page for details.   \n\n*参考式*的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：\n\n    This is [an example][id] reference-style link.\n\n你也可以选择性地在两个方括号中间加上一个空格：\n\n    This is [an example] [id] reference-style link.\n\n接着，在文件的任意处，你可以把这个标记的链接内容定义出来：\n\n    [id]: http://example.com/  \"Optional Title Here\"\n\n链接内容定义的形式为：\n\n*   方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字\n*   接着一个冒号\n*   接着一个以上的空格或制表符\n*   接着链接的网址\n*   选择性地接着 title 内容，可以用单引号、双引号或是括弧包着\n\n下面这三种链接的定义都是相同：\n\n\t[foo]: http://example.com/  \"Optional Title Here\"\n\t[foo]: http://example.com/  'Optional Title Here'\n\t[foo]: http://example.com/  (Optional Title Here)\n\n**请注意：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。\n\n链接网址也可以用尖括号包起来：\n\n    [id]: <http://example.com/>  \"Optional Title Here\"\n\n你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：\n\n    [id]: http://example.com/longish/path/to/resource/here\n        \"Optional Title Here\"\n\n网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。\n\n链接辨别标签可以有字母、数字、空白和标点符号，但是并*不*区分大小写，因此下面两个链接是一样的：\n\n\t[link text][a]\n\t[link text][A]\n\n*隐式链接标记*功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 \"Google\" 链接到 google.com，你可以简化成：\n\n\t[Google][]\n\n然后定义链接内容：\n\n\t[Google]: http://google.com/\n\n由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：\n\n\tVisit [Daring Fireball][] for more information.\n\n然后接着定义链接：\n\n\t[Daring Fireball]: http://daringfireball.net/\n\n链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。\n\n下面是一个参考式链接的范例：\n\n    I get 10 times more traffic from [Google] [1] than from\n    [Yahoo] [2] or [MSN] [3].\n\n      [1]: http://google.com/        \"Google\"\n      [2]: http://search.yahoo.com/  \"Yahoo Search\"\n      [3]: http://search.msn.com/    \"MSN Search\"\n\n如果改成用链接名称的方式写：\n\n    I get 10 times more traffic from [Google][] than from\n    [Yahoo][] or [MSN][].\n\n      [google]: http://google.com/        \"Google\"\n      [yahoo]:  http://search.yahoo.com/  \"Yahoo Search\"\n      [msn]:    http://search.msn.com/    \"MSN Search\"\n\n上面两种写法都会产生下面的 HTML。\n\n    <p>I get 10 times more traffic from <a href=\"http://google.com/\"\n    title=\"Google\">Google</a> than from\n    <a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\">Yahoo</a>\n    or <a href=\"http://search.msn.com/\" title=\"MSN Search\">MSN</a>.</p>\n\n下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：\n\n    I get 10 times more traffic from [Google](http://google.com/ \"Google\")\n    than from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or\n    [MSN](http://search.msn.com/ \"MSN Search\").\n\n参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。\n\n使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。\n\n<h3 id=\"em\">强调</h3>\n\nMarkdown 使用星号（`*`）和底线（`_`）作为标记强调字词的符号，被 `*` 或 `_` 包围的字词会被转成用 `<em>` 标签包围，用两个 `*` 或 `_` 包起来的话，则会被转成 `<strong>`，例如：\n\n    *single asterisks*\n\n    _single underscores_\n\n    **double asterisks**\n\n    __double underscores__\n\n会转成：\n\n    <em>single asterisks</em>\n\n    <em>single underscores</em>\n\n    <strong>double asterisks</strong>\n\n    <strong>double underscores</strong>\n\n你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。\n\n强调也可以直接插在文字中间：\n\n    un*frigging*believable\n\n但是**如果你的 `*` 和 `_` 两边都有空白的话，它们就只会被当成普通的符号**。\n\n如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：\n\n    \\*this text is surrounded by literal asterisks\\*\n\n<h3 id=\"code\">代码</h3>\n\n如果要标记一小段行内代码，你可以用反引号把它包起来（`` ` ``），例如：\n\n    Use the `printf()` function.\n\n会产生：\n\n    <p>Use the <code>printf()</code> function.</p>\n\n如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：\n\n    ``There is a literal backtick (`) here.``\n\n这段语法会产生：\n\n    <p><code>There is a literal backtick (`) here.</code></p>\n\n代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：\n\n\tA single backtick in a code span: `` ` ``\n\t\n\tA backtick-delimited string in a code span: `` `foo` ``\n\n会产生：\n\n\t<p>A single backtick in a code span: <code>`</code></p>\n\t\n\t<p>A backtick-delimited string in a code span: <code>`foo`</code></p>\n\n在代码区段内，`&` 和尖括号**都**会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：\n\n    Please don't use any `<blink>` tags.\n\n转为：\n\n    <p>Please don't use any <code>&lt;blink&gt;</code> tags.</p>\n\n你也可以这样写：\n\n    `&#8212;` is the decimal-encoded equivalent of `&mdash;`.\n\n以产生：\n\n    <p><code>&amp;#8212;</code> is the decimal-encoded\n    equivalent of <code>&amp;mdash;</code>.</p>\n\n\n\n<h3 id=\"img\">图片</h3>\n\n很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。\n\nMarkdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： *行内式*和*参考式*。\n\n行内式的图片语法看起来像是：\n\n    ![Alt text](/path/to/img.jpg)\n\n    ![Alt text](/path/to/img.jpg \"Optional title\")\n\n详细叙述如下：\n\n*   一个惊叹号 `!`\n*   接着一个方括号，里面放上图片的替代文字\n*   接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上\n    选择性的 'title' 文字。\n\n参考式的图片语法则长得像这样：\n\n    ![Alt text][id]\n\n「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：\n\n    [id]: url/to/image  \"Optional title attribute\"\n\n到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 `<img>` 标签。\n\n* * *\n\n<h2 id=\"misc\">其它</h2>\n\n<h3 id=\"autolink\">自动链接</h3>\n\nMarkdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n\n    <http://example.com/>\n\nMarkdown 会转为：\n\n    <a href=\"http://example.com/\">http://example.com/</a>\n\n邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：\n\n    <address@example.com>\n\nMarkdown 会转成：\n\n    <a href=\"&#x6D;&#x61;i&#x6C;&#x74;&#x6F;:&#x61;&#x64;&#x64;&#x72;&#x65;\n    &#115;&#115;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6C;e&#x2E;&#99;&#111;\n    &#109;\">&#x61;&#x64;&#x64;&#x72;&#x65;&#115;&#115;&#64;&#101;&#120;&#x61;\n    &#109;&#x70;&#x6C;e&#x2E;&#99;&#111;&#109;</a>\n\n在浏览器里面，这段字串（其实是 `<a href=\"mailto:address@example.com\">address@example.com</a>`）会变成一个可以点击的「address@example.com」链接。\n\n（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）\n\n<h3 id=\"backslash\">反斜杠</h3>\n\nMarkdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `<em>` 标签），你可以在星号的前面加上反斜杠：\n\n    \\*literal asterisks\\*\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n    \\   反斜线\n    `   反引号\n    *   星号\n    _   底线\n    {}  花括号\n    []  方括号\n    ()  括弧\n    #   井字号\n    +   加号\n    -   减号\n    .   英文句点\n    !   惊叹号\n\n<h2 id=\"acknowledgement\">感谢</h2>\n\n感谢 [leafy7382][] 协助翻译，[hlb][]、[Randylien][] 帮忙润稿，[ethantw][] 的[汉字标准格式・CSS Reset][]， [WM][] 回报文字错误。\n\n[leafy7382]:https://twitter.com/#!/leafy7382\n[hlb]:http://iamhlb.com/\n[Randylien]:http://twitter.com/randylien\n[ethantw]:https://twitter.com/#!/ethantw\n[汉字标准格式・CSS Reset]:http://ethantw.net/projects/han/\n[WM]:http://kidwm.net/\n\n感谢 [fenprace][]，[addv][]。\n\n[fenprace]:https://github.com/fenprace\n[addv]:https://github.com/addv\n\n----------\n<h2 id=\"editor\">Markdown 免费编辑器</h2>\n\nWindows 平台\n\n* [MarkdownPad](http://markdownpad.com/)\n* [MarkPad](http://code52.org/DownmarkerWPF/)\n\nLinux 平台\n\n* [ReText](http://sourceforge.net/p/retext/home/ReText/)\n\nMac 平台\n\n* [Mou](http://mouapp.com/)\n\n在线编辑器\n\n* [Markable.in](http://markable.in/)\n* [Dillinger.io](http://dillinger.io/)\n\n浏览器插件\n\n* [MaDe](https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog) (Chrome)\n\n高级应用\n\n* [Sublime Text 2](http://www.sublimetext.com/2) + [MarkdownEditing](http://ttscoff.github.com/MarkdownEditing/) / [教程](http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/)\n\n\\*** 如有更好的 Markdown 免费编辑器推荐，请到[这里反馈](https://gitcafe.com/riku/Markdown-Syntax-CN/tickets/1)，谢谢！\n","tags":["markdown"]},{"title":"在个人网页上加入网易云音乐的歌曲","url":"/2018/07/28/在个人网页上加入网易云音乐的歌曲/","content":"想在博客中加入可以播放的歌曲链接。自行百度后找到了网易云音乐提供的外链播放器功能。\n\n通过网易云音乐网页版，可以生成外链播放器的代码。\n\n不过一些有版权限制的歌曲是不能生成外链播放器播放的哦。\n\n提供了两种形式。\n\n### 第一种.通过单首歌曲生成\n\n#### 操作过程\n\n 在网易云音乐网页版中选择一首歌曲，进入歌曲播放页面。在左边选择`生成外链播放器`。\n\n![网易云音乐网页版](/img/2018-07-28-1.jpg)\n\n 然后进入播放器生成页面，配置样式，一键复制代码\n\n![网易云音乐网页版](/img/2018-07-28-2.jpg)\n\n#### 代码\n\n```html\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=496869422&auto=0&height=66\"></iframe>\n```\n\n#### 实际效果\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=496869422&auto=0&height=66\"></iframe>\n\n###  第二种.通过专辑/歌单生成\n\n 在网易云音乐网页版中选择一张专辑/歌单。在列表上方选择`生成外链播放器`。\n\n![网易云音乐网页版](/img/2018-07-28-3.jpg)\n\n 然后进入播放器生成页面，配置样式，一键复制代码\n\n过程与上一个类似\n\n#### 代码\n```html\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"//music.163.com/outchain/player?type=1&id=34753163&auto=0&height=430\"></iframe>\n```\n\n#### 实际效果\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"//music.163.com/outchain/player?type=1&id=34753163&auto=0&height=430\"></iframe>\n\n### 解释说明\n\n* id：歌曲id \n\n* auto：0/1\n\n  * 0表示打开网页的时候不自动播放； \n\n  * 1表示打开网页的时候自动播放。\n","tags":["hexo"]},{"title":"使用gh-pages+Hexo搭建个人网页教程","url":"/2018/07/27/使用gh-pages+Hexo搭建个人网页教程/","content":"\n# 前言\n\n使用github pages服务搭建博客的好处有：\n\n1. 全是静态文件，访问速度快；\n2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；\n3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；\n4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；\n5. 博客内容可以轻松打包、转移、发布到其它平台；\n6. 等等；\n\n## 准备工作\n\n确保你完成了下列准备：\n\n* 有一个github账号，没有的话去注册一个；\n* 安装了node.js、npm，并了解相关基础知识；\n* 安装了git for windows（或者其它git客户端）\n\n<!--more-->\n\n# 搭建github博客\n\n## 创建仓库\n\n新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是Ngwind，那么你就新建Ngwinf.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 [http://Ngwind.github.io](http://Ngwind.github.io) 了，是不是很方便？\n\n## 绑定域名\n\n当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。\n\n首先你要注册一个域名，域名注册以前总是推荐去godaddy，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！\n\n# 配置SSH Key\n\n为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。\n\n用git bash执行如下命令：\n\n`$ cd ~/. ssh #检查本机已存在的ssh密钥`\n\n如果提示：No such file or directory 说明你是第一次使用git。\n\n`ssh-keygen -t rsa -C \"邮件地址\"`\n\n然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到`.ssh\\id_rsa.pub`文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -> SSH and GPG keys -> New SSH key：\n\n## 测试是否成功\n\n等后面上传代码带github时，再验证吧~\n\n此时你还需要配置：\n\n```git\n$ git config --global user.name \"liuxianan\"// 你的github用户名，非昵称\n$ git config --global user.email  \"xxx@qq.com\"// 填写你的github注册邮箱\n\n```\n\n# 使用hexo写博客\n\n## hexo简介\n\nHexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。\n\n官网： http://hexo.io\n\ngithub: https://github.com/hexojs/hexo\n\n## 原理\n\n由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。\n\n## 注意事项\n\n安装之前先来说几个注意事项：\n\n1. 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；\n1. hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导；\n1. hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的；\n\n## 安装\n\n打开gitbash，运行下面的命令：\n\n`$ npm install -g hexo`\n\n## 初始化\n\n在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\\Workspaces\\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。\n\n```git\n$ cd /f/Workspaces/hexo/\n$ hexo init\n```\n\nhexo会自动下载一些文件到这个目录，包括node_modules.\n\n接着执行以下命令：\n\n```git\n$ hexo g # 生成\n$ hexo s # 启动服务\n```\n\n执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的.\n\n`hexo s`是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：\n\nhttp://blog.liuxianan.com/windows-port-bind.html\n\n第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，打开时就是这个样子：\n\n![第一次的页面](http://image.liuxianan.com/201608/20160818_132443_202_6848.png)\n\n## 修改主题\n\n我们别的不做，首先来替换一个好看点的主题。这是 官方主题。\n\n个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。\n\n首先下载这个主题：\n\n~~~git\n$ cd /f/Workspaces/hexo/\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n\n~~~\n\n下载后的主题这都保存在hexo/themes文件夹中\n\n修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。\n\n如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。\n\n## 上传之前\n\n在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。\n\n## 上传到github\n\n如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。\n\n首先，ssh key肯定要配置好。\n\n其次，配置_config.yml中有关deploy的部分：\n\n正确写法：\n\n```git\ndeploy:\n  type: git\n  repository: git@github.com:liuxianan/liuxianan.github.io.git\n  branch: master\n```\n错误写法：\n\n```git\ndeploy:\n  type: github\n  repository: https://github.com/liuxianan/liuxianan.github.io.git\n  branch: master\n```\n后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误：\n```git\nDeployer not found: github 或者 Deployer not found: git\n```\n原因是还需要安装一个插件：\n```git\nnpm install hexo-deployer-git --save\n```\n打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会：\n\n![1](http://image.liuxianan.com/201608/20160818_140441_769_5024.png)\n\n## 保留CNAME、README.md等文件\n\n提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的：\n\n![2](http://image.liuxianan.com/201608/20160818_141037_580_8035.png)\n\n由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。\n\n## 常用命令\n\n常见命令\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\n```\n缩写：\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n组合命令：\n```\nhexo s -g #生成并本地预览\nhexo d -g #生成并上传\n```\n\n## _config.yml\n\n这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。\n\n需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。\n\n## 写博客\n\n定位到我们的hexo根目录，执行命令：\n```\nhexo new 'my-first-blog'\n```\nhexo会帮我们在_posts下生成相关md文件：\n![3](http://image.liuxianan.com/201608/20160823_183047_352_1475.png)\n我们只需要打开这个文件就可以开始写博客了.\n\n当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。\n\n一般完整格式如下：\n\n```text\n---\ntitle: postName #文章页面上的显示名称，一般是中文\ndate: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改\ncategories: 默认分类 #分类\ntags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面\n---\n\n以下是正文\n```\n\n### 写博客工具\n\n我个人使用微软的vxcode\n\n### 如何让博文列表不显示全部内容\n\n默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？\n\n答案是在合适的位置加上`<!--more-->`即可。\n\n## 最终效果\n\n参考我的网页：[这里](Ngwind.gihub.io)\n\n## 参考\n\nhttp://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa#ru-he-rang-bo-wen-lie-biao-bu-xian-shi-quan-bu-na-rong\n\nhttp://www.cnblogs.com/zhcncn/p/4097881.html\n\nhttp://www.jianshu.com/p/05289a4bc8b2","tags":["hexo"]}]